<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（二）]]></title>
    <url>%2F2019%2F07%2F17%2Fwechat-account-02%2F</url>
    <content type="text"><![CDATA[上次微信公众号制作记账功能（一）把nodejs的环境搭好了，并且可以简单地回复用户地信息了，那么接下来就要正式实现我们地功能了。 为了方便大家查看，也方便大家自己部署到公众号上，我把代码放到github上了，有兴趣可以去看一下。 一、功能分发因为我的订阅号的权限十分有限，那么基本上就只能靠用户的输入来猜测命令了，打开/routes/wx.js，找到处理普通文字消息的代码，进行如下修改： 12345678910111213// 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 moneyManager.doQuery(json.xml).then(msg =&gt; &#123; if (!msg) &#123; tempBody.xml.Content = '你好,我在努力进步中哦...' &#125; else &#123; tempBody.xml.Content = msg &#125; resbody = jParser.parse(tempBody) res.send(resbody) &#125;) &#125; 1、链式调用模块首先我的需求是不止有记账这一种功能，可以想见，那么多命令，如果都在wx.js里判断，那以后光找功能就要找好久。 我的思路是，将命令划分为几个模块，然后每个模块有自己专门的命令分发方法，每个模块处理完之后，wx.js就只负责将处理的结果返回给用户。 那么怎么判断这个命令属于哪个模块呢？我的想法是利用Promise的链式调用，如果上一个模块没有返回值，就执行下一个模块的命令分发，直至匹配到一个模块。类似下面这种方式： 12345678910111213function modelA() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;function modelB() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;modelA().then((res) =&gt; &#123; if (!res) &#123; return modelB() &#125; else &#123; return '' &#125;&#125;) 目前只定义了一个模块，暂时看不出效果，不过后面我会定义一个默认模块，即若前面的模块都没有匹配到命令时，进入该模块返回一个默认的回复信息。 2、命令识别 人工智能离用户很近，但离开发者很远~ 首先，记账模块有三个子功能：记账、查询账单、统计，而且记账时我想让用户直接输入，因为输入就已经够麻烦了，不能再增加步骤了。 那么在分发的入口就先去匹配固定的命令，如果没有匹配到，再去匹配记账这个随机性很大的命令。而在匹配记账的过程中，我用的是比较笨的方法，定义一个用户可能会输入的数组，然后再去匹配。 下面放上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// /service/money.jsconst keywords = [ '吃饭', '购物', '工资', '日用', '交通', '零食', '运动', '娱乐', '通讯', '服饰', '住房', '居家', '社交', '旅行', '烟酒', '数码', '医疗', '书籍', '礼物', '快递', '水果', '蔬菜', '亲友', '彩票', '捐赠', '维修', '办公', '宠物', '学习', '汽车', '美容', '兼职', '理财', '礼金', '早餐', '午餐', '晚餐', '早饭', '午饭', '晚饭']const mt = [-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1]// 功能分发const doQuery = (payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 在此处比较数量是否一致，防止输入时出错 if (process.env.NODE_ENV === 'development') &#123; console.log('记账关键词与盈亏数量对比：', keywords.length, mt.length) &#125; if (payload.Content === '账单') &#123; queryBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else if (payload.Content === '统计') &#123; tongji(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else &#123; // 记账 addBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; &#125;)&#125;// 记账const addBill = (&#123;FromUserName, CreateTime, Content, MsgId&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let index = -1 keywords.some((item, idx) =&gt; &#123; if (Content.indexOf(item) &gt;= 0) &#123; index = idx return true &#125; &#125;) if (index &gt;= 0) &#123; const price = parseFloat(Content.replace(keywords[index], '')) if (!price) &#123; res('错误提示：未输入金额或金额格式错误\n所属模块：[记账]') &#125; else &#123; const tempTxt = mt[index] &gt; 0 ? '收入' : '支出' retMsg = `记录成功！\n$&#123;keywords[index]&#125; $&#123;tempTxt&#125; $&#123;price&#125;元` res(retMsg) &#125; &#125; else &#123; res('') &#125; &#125;)&#125;// 查询账单const queryBill = (&#123;FromUserName, CreateTime&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; var str = '您的账单如下:\n' res(str) &#125;) &#125;)&#125;// 统计const tongji = () =&gt; &#123;&#125;module.exports = &#123; doQuery&#125; 我将模块都放在service目录，以便统一管理。上面的代码Promise用得总感觉有点别扭，但还是可以正常运行的，等哪天开窍了估计就能写出更优雅的代码了。 二、数据存储记账记账，如果不存下来，那还叫什么记账？ 1、简单介绍nodejs在数据存储方面的选择其实有很多种，但限于我的服务器很菜，我只能选择基于文件系统的数据库了，那就排除掉MySql、Redis。然后我听人推荐LevelDb，好家伙，感觉比Redis难用多了，我就想简单地放个对象数组，放了大半天都失败了，还读取不到！然后又把目光放到Sqlite3上面，又是一个好家伙，我还要在代码中定义数据结构，这还是我印象中地js吗？ 就在我彷徨不所知时，一道闪电击中了我的脑袋，nedb!赶忙在github上搜索，竟然搜到了这个数据库，然后赶紧试试能不能用，好不好用。用过之后，我只有一个感觉，丝滑~ 我就稍微介绍一下它吧（太丝滑了，必须得多说几句啊），nedb是mongoDb的一个子集，mongoDb相信大家会有所耳闻，而子集，就是将mongoDb的常用操作抽取出来了，所以用着是真的顺手。啥也不说了，先放链接： https://github.com/louischatriot/nedb 这是我生成的数据库文件，没错，只有一个文件，文件内容肉眼可读！一个字，强啊。 2、应用在nedb中，一个表就是一个文件（个人肤浅见解），因此管理表的任务就交给我们了。 我的做法是专门用一个文件/service/db.js去管理数据库信息: 12345678var Datastore = require('nedb')// 生成nedb的实例并自动打开数据库var moneyDb = new Datastore(&#123; filename: 'moneyLog.db', autoload: true &#125;)// 这里我考虑到项目中不止会用到一张表，就用这种方式导出多个nedb的操作对象module.exports = &#123; moneyDb&#125; 然后在/service/money.js中的用法就是： 123456789101112131415161718192021222324// 构造账单记录const bill = &#123; msgId: MsgId, type: keywords[index], yk: mt[index], price: price, openid: FromUserName, recordTime: CreateTime&#125;// 没错，就这么简单就插入了db.moneyDb.insert(bill)// ...var str = '您的账单如下:\n'// 查询也很简单，还可以排序，具体的可以看github上的文档db.moneyDb.find(&#123;openid: FromUserName&#125;).sort(&#123;recordTime: -1&#125;).exec((err, docs) =&gt; &#123; docs.forEach(item =&gt; &#123; const d = dateUtil.getNowSimpleFormatDate(new Date(CreateTime * 1000)) const s = `[$&#123;d&#125;] $&#123;item.type&#125; $&#123;item.price&#125;元\n` str += s&#125;)res(str)&#125;) 做到这一步之后，就可以运行查看效果了。 可以看到，这里我专门取消关注后再新增的记录，一样可以获取到以前的记录。 当然，这个功能还有许多地方要完善，比如支持查询啦，支持翻页啦，这些就放到下次再讲吧。 三、自适应环境这个标题实在想不到既简短又直击要害的了… 通常情况下，我们的开发环境和生产环境的配置信息是有所不同的，那我们每次切换环境都要重新手动修改配置文件吗？ 这当然不行。 以前这种区分开发环境和生产环境的功能也用过，不过都是别人写好的模板，这次总算自己实现了一下。 原理很简单，我们的系统都是可以设置环境变量的，而我们平常运行项目执行的yarn start或者npm start其实都是执行的package.json中配置的scripts: {&quot;start&quot;: &quot;node xxxx.js&quot;}这种命令。那我们就可以在执行这个命令之前先将系统的环境变量设为开发环境或生产环境，然后程序里读取当前是开发环境还是生产环境，然后加载不同的配置文件就可以了。 首先，了解一下设置环境变量的方式： 1234# windows系统set NODE_ENV=development# Linux/Mac系统export NODE_ENV=development 不同操作系统的命令不一样，这确实给我造成了不小的困扰，但也只能在不同的系统上再手动改一下了。 然后修改packages.json： 12345// 开发环境是windows，因此先设置为windows的命令"scripts": &#123; "dev": "set NODE_ENV=development&amp;&amp; nodemon ./bin/www", "prod": "set NODE_ENV=production&amp;&amp; nodemon ./bin/www" &#125;, 上面用到了&amp;&amp;用于在同一行内区分两条命令，同时要注意的是，&amp;&amp;前面不能用空格分开！，这导致我一直无法区分开发环境和生产环境。 这样修改之后，在js代码中，就可以通过以下代码进行判断： 1if (process.env.NODE_ENV === 'development')&#123;&#125; 这样设置完成基本上就可以了，但因为我想把代码放到github上让大家参考，又不能把自己的密钥之类的放在上面，那么我就还需要想点褶子。 首先，项目中要将开发环境和生产环境的配置文件分开，同时要将私密信息单独创建一个文件，还要有一个文件专门放不会变的配置信息。因此，我的config文件夹就变成了这个样子： 其中*.self.js是我配置私密信息的地方，然后在dev.js中获取，最后在index.js中判断环境后获取对应的配置信息。然后，我再将*.self.js的文件设置为忽略上传就可以了。不过这样的话我又要去写README.md了。。。 下面附上index.js中区分环境的代码： 12345678910const devConfig = require('./dev')const prodConfig = require('./prod')// 区分开发环境和生产环境const env = process.env.NODE_ENV || 'development'var isDev = env === 'development'// 每次启动时会打印当前运行环境，更好的提醒使用者console.log('当前运行环境：',env)const appid = isDev ? devConfig.appid : prodConfig.appid 总结在做这个记账功能的时候，数据库的选择真的是卡了我好长时间，还好有那一道闪电~ 最后，希望大家可以关注一下我的公众号，体验一下微信记账的感觉~]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（一）]]></title>
    <url>%2F2019%2F07%2F16%2Fwechat-account-01%2F</url>
    <content type="text"><![CDATA[一直想写一个记账软件，但界面的设计真让我头大。这不，刚买了个服务器，那用这个当后台存储，微信公众号菜单作为界面交互，练个手？ 我的服务器只有512M内存，10G硬盘，跑Java就别想了。刚刚看自己的SpringBoot应用跑在自己电脑上就占了479M内存，这还没说Mysql呢，服务器还挂着SSR，没办法，不能用Java来开发了。 从网上查找Java、Python、nodejs、php的性能比较，都说nodejs性能最好，那就玩nodejs喽（当然我在python上纠结过，不过nodejs一是比较熟悉，而是自己想实现的聊天机器人可以通过API调用来实现，也就是python能做的nodejs都有替代方案，性能又好，那必须选它了） 一、环境搭建1、安装express这里就参考Express官方文档一步步操作的。 不过官方文档稍微有点啰嗦，说了前一步，结果后面告诉你前面的方法太Low了。所以这里我就把关键部分再描述一遍。 全局安装Express脚手架： 1$ yarn global add express-generator 创建项目： 1$ express --view=pug myapp 如果不输入项目名[myapp]，就会在当前目录生成各种文件。 如果不输入–view=pug，控制台会报错jade模板不能用之类的事，我怂，我输入。 进入项目，安装依赖并运行： 123$ cd myapp$ yarn$ yarn start 2、控制台输出端口信息这时控制台是很干巴巴的，对于就喜欢看控制台不停输出信息的Java开发者来说，难受吖。 打开/bin/www，找到末尾的onListening方法，这样进行改动： 12345function onListening() &#123; // ... debug('Listening on ' + bind); console.log('Listening on ' + bind)&#125; 然后控制台就会输出Listening on port 3000了，舒服了舒服了。 3、代码自动刷新习惯了vuejs的自动刷新，每每改完文件还要Ctrl + C、Y、⬆是真的痛苦。还好我有~ nodemon 首先全局安装nodemon： 1$ yarn global add nodemon 打开package.json，修改scripts： 1"start": "nodemon ./bin/www" 依旧是原来的配方，yarn start启动项目，舒服了舒服了。 二、与微信服务器“配对”申请微信公众号之后，在开发者工具中找到公众平台测试账号，填写接口配置信息。 当然现在点击保存肯定是提示配置失败的，下面我们开始配置自己的Express服务器来正确响应微信服务器的消息。 在/routes/目录下新建wx.js文件，直接把user.js的内容复制过来。打开app.js，仿照user.js导入路由的方式： 12var wxRouter = require('./routes/wx')app.use('/cqm/wx', wxRouter) 然后在测试号的页面再次点击保存，这次不是为了配对成功，而是查看接口会传来什么参数，然后我们需要验证这是微信服务器发来的消息。 此时需要安装一个模块用来加密信息： 1$ yarn add jssha --dev 然后就是根据传来的参数验证信息，成功后把echostr字段返回给微信服务器。 12345678910111213141516171819202122232425// 微信服务器认证router.get('/', function(req, res, next) &#123; // 1 获取微信服务器请求参数 var signature = req.query.signature // 加密签名 var timestamp = req.query.timestamp // 时间戳 var nonce = req.query.nonce // 随机数 var echostr = req.query.echostr // 随机字符串 console.log(`接收到微信服务器认证请求`) // 2 将token timestamp nonce 按字典序排序 var array = [config.token, timestamp, nonce] array.sort() // 3 将参数加密 var tempStr = array.join('') var shaObj = new jsSHA('SHA-1', 'TEXT') shaObj.update(tempStr) var scyptoStr = shaObj.getHash('HEX') // 4 将加密后的字符串与signature对比，相同则表示验证成功 if (signature === scyptoStr) &#123; console.log('验证成功') res.send(echostr) &#125; else &#123; console.log('验证失败') res.send('验证失败') &#125;&#125;); 保存后在微信测试号里再次保存配置信息，就可以保存成功了。 我在测试时用到了一个公司的反向代理工具，把自己电脑映射到服务器的指定网址了。其实原理是差不多的，你只要有一台自己的服务器，在上面配置nginx反向代理，映射到你本机，就可以实现开发环境与微信服务器联调了。 三、响应用户发来的消息微信服务器会把用户发送的消息以post方式发送到刚刚验证的接口，同样的，我们需要正确回复微信服务器。 1234567891011121314// 微信服务器消息接收router.post('/', (req, res, next) =&gt; &#123; var signature = req.query.signature var timestamp = req.query.timestamp var nonce = req.query.nonce var openid = req.query.openid // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`)&#125;) 然后手机关注自己的测试号并随便发送一个消息，就可以看到自己的回复了： 还是很神奇的，不过到这一步只是简单实现了回复消息，实际上我们没有识别用户的输入，也没有做其他复杂的机制，比如5秒内无法回复时要先返回success告知微信服务器我收到消息了，还要应对微信服务器的3次重试机制。 下面就先实现识别用户发送消息的功能： 在nodejs中，接收post请求参数的方式和Java的不一样，Java直接就可以获取了，而nodejs还要等待数据传输完毕。因此我们就需要先监听数据传输事件，并将数据保存到一个buffer中，然后监听接收完成的事件，接着才是处理数据及返回消息的步骤： 12345678910111213141516 var buffer = []// 监听data事件 用于接收数据 req.on('data', data =&gt; &#123; buffer.push(data) &#125;) // 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; console.log(Buffer.concat(buffer).toString('utf-8')) // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`) &#125;) 用惯了Java的我，发现不能直接获取post请求参数之后，我还傻傻地去找转换工具，结果看到了一个body-parser，用了之后发现没效果。算了算了，入乡随俗。 这样修改之后，就可以获取到用户发来的消息了： 下面就是解析信息了（看到请求消息才明白官方文档的![CDATA[]]是不能省略的，但竟然识别出了我的回复，强吖） 安装fast-xml-parser： 1$ yarn add fast-xml-parser 解析xml数据： 12345var xmlParser = require('fast-xml-parser')var xml = Buffer.concat(buffer).toString('utf-8')console.log(xml)var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml))console.log(json) 然后，我们熟悉的json就又回来啦： 四、自定义菜单被动回复我们现在可以做到了，下面就是要主动向微信服务器发送消息告诉它我们要设置菜单项！ 1、获取access_token与微信服务器的很多交互都需要用到access_token的，而access_token有7200秒（2小时）的有效期，那我们需要做的，就是在项目启动后获取一次access_token，并且启动一个定时器，每隔7000秒重新获取一次。 因为习惯了vue.js的开发模式，我这里在项目根目录下新建了/api/wx.js文件，专门负责发送微信请求。在请求库的选择上，因为我们现在是服务端，不可能只请求一个域名，那么用axios设置baseUrl的方式就不是特别合适，就直接用request库来发送请求就好了，每次请求都定义一下url，也没有特别麻烦，而且我看很多人都这么用，那应该不会错了。 安装request和querystring： 12$ yarn add request$ yarn add querystring 其中querystring是将json数据转换为url请求参数的库 然后开始编写请求方法： 1234567891011121314151617181920212223242526var config = require('../config/index')var qs = require('querystring')var request = require('request')// 获取AccessTokenconst getAccessToken = () =&gt; &#123; const params = &#123; 'grant_type': 'client_credential', 'appid': config.appid, 'secret': config.appsecret &#125; const url = `$&#123;config.wxUrl&#125;cgi-bin/token?$&#123;qs.stringify(params)&#125;` // console.log('getAccessToken请求地址为', url) return new Promise((resolve, reject) =&gt; &#123; request(&#123; method: 'GET', url: url &#125;, (err, res, body) =&gt; &#123; if (res) &#123; resolve(JSON.parse(body)) &#125;else&#123; reject(err) &#125; &#125;) &#125;)&#125; 打开/bin/www： 1234567891011121314151617var wxAPI = require('../api/wx')function onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000);&#125; 然后重新运行项目，就会在控制台打印出我们获取到的token，这里将access_token保存到了global全局对象中，方便其他地方使用。 nodemon好像不会监听www文件的修改，所以需要我们重新启动服务。 2、配置自定义菜单有了access_token，我们就可以放心地向微信服务器发送请求了。但在此之前，我们还没有定义自己的菜单呢。我这里将菜单保存为json格式，同时也是熟悉一下文件操作： /config/wxmenus.json 12345678910111213141516171819202122232425262728293031323334&#123; "button": [ &#123; "name": "记账", "sub_button": [ &#123; "type": "click", "name": "收入", "key": "add_money" &#125;, &#123; "type": "click", "name": "支出", "key": "sub_money" &#125;, &#123; "type": "click", "name": "账单", "key": "bill" &#125;, &#123; "type": "click", "name": "预算", "key": "wish" &#125; ] &#125;, &#123; "type": "click", "name": "待办", "key": "todo_list" &#125; ]&#125; 因为我要做记账的功能，所以就预先把菜单定义好，后面也省得再去调整了。 首先尝试一下能否正确读取出json文件： /api/wx.js 12345678910111213141516var fs = require('fs')// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 var m = JSON.parse(data.toString()) resolve(m) &#125; &#125;) &#125;)&#125; 注意这里的文件路径是基于项目路径而不是wx.js当前路径。 然后同样在www中的onListening添加调用： 123456// 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) 重启服务就会在控制台看到我们要的结果： 下面继续修改wx.js，将我们配置的菜单发送给微信服务器。 1234567891011121314151617181920212223242526// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 const menuData = data.toString() const url = `$&#123;config.wxUrl&#125;cgi-bin/menu/create?access_token=$&#123;global.access_token&#125;` request(&#123; method: 'POST', url: url, form: menuData &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(JSON.parse(body)) &#125; &#125;) &#125; &#125;) &#125;)&#125; 改完这个之后还不够，因为这里用到了access_token，我们必须保证在发送菜单的这个请求时我们已经获取到了access_token，那么我们就要修改www文件： 1234567891011121314151617181920212223242526var isInit = falsefunction onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) if (!isInit) &#123; // 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) isInit = true &#125; &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000)&#125; 这里就是通过一个标志位来判断获取access_token后是否还需要发送设置菜单的请求。然后取消关注测试号，再重新关注一下： 可以看到我们的菜单已经设置生效了。在这个过程中我还注意到控制台还接收到了用户关注和取消关注事件的请求，这表明这个post接口不只是用来接收消息的，应该还有其他用处。 3、接收菜单点击事件到这一步就要参考微信官方文档给的事件类型了，然后在/routes/wx.js中根据不同类型做出不同回应即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; var xml = Buffer.concat(buffer).toString('utf-8') var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml)) console.log(json) // 定义返回消息 var resbody = 'success' var tempBody = &#123; xml: &#123; ToUserName: json.xml.FromUserName, FromUserName: json.xml.ToUserName, CreateTime: timestamp, MsgType: 'text' &#125; &#125; var jParser = new xmlParser.j2xParser() // 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 tempBody.xml.Content = '你好,我在努力进步中哦...' resbody = jParser.parse(tempBody) &#125; else if (json.xml.MsgType === 'event') &#123; // 事件类型 一共有六种事件1 关注/取消关注事件 2 扫描带参数二维码事件 3 上报地理位置事件 4 自定义菜单事件 5 点击菜单拉取消息时的事件推送 6 点击菜单跳转链接时的事件推送 if (json.xml.Event === 'CLICK') &#123; // 自定义菜单事件 tempBody.xml.Content = `您点击了$&#123;json.xml.EventKey&#125;` resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'subscribe') &#123; // 关注事件 tempBody.xml.Content = '欢迎关注' resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'unsubscribe') &#123; // 取消关注事件 该事件不能给用户发送消息 resbody = '' &#125; else if (json.xml.Event === 'LOCATION') &#123; // 上报地理位置事件 暂时不考虑 resbody = '' &#125; else &#123; // 其他事件有点复杂，先不做处理 &#125; &#125; res.send(resbody) &#125;) 然后取消关注测试号再重新关注，将刚刚的几种事件类型试一下，看看会不会做出正确的响应即可。 五、部署到正式的公众号我的服务器是CentOS，并且是刚刚创建的，一片空白，那现在就需要安装nodejs环境和ftp服务了。 以前自己在Linux下安装过ftp，不过失败了。但这次！看了leoxuan的CentOS7 FTP安装与配置后，我成功了！ 大家在按着这个教程来的时候用户名一定要弄对，上面截图中的一个错误就是我直接复制文章中的代码忽略了用户名才出错的。 传输文件时我这里一直无法传输，按文章中说的关闭SeLinux也不行，更改权限775不起作用，最后索性改为777才可以成功上传。 下面，在app.js中修改我们的代码，不再监听/cqm/wx了，这次翻身做主人，直接监听/wx！ 然后打包（压缩）项目，上传到服务器。 下面需要在服务器安装nodejs，这里我是参照CentOS7.5安装nodejs进行安装的。我选择的是第二种方法，毕竟以后全局安装插件就可以省点事了。 不过编译真的好慢啊，我写完这行字的时候它还没有编译好。。。 上面的安装对我来说完全不起作用，又参考了一篇文章在CentOS 7上安装Node.js的4种方法（包含npm）,用其中的第四种方法，终于是成功了，下面我把命令粘贴一下，方便以后使用。 123456curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bashsource ~/.bash_profilenvm list-remotenvm install v10.16.0node -vnpm 然后再安装我们需要的各种依赖，就可以使用yarn start启动项目了。 但我们的服务是放在3000端口的，我们需要配置nginx服务器的反向代理。 1234567server &#123; listen 80; server_name aqzscn.com; location / &#123; proxy_pass http://127.0.0.1:3000/wx; &#125;&#125; 经过一番配置，运行，然后在微信公众号上配置自己的服务器信息（不要忘记修改Appid和Secret为公众号的），然后你就会发现，还有一大堆问题要解决。 其中ip不在白名单的问题好解决，直接在公众号上设置就好了，但下面的问题是真的没办法解决。 没有权限。。好忧桑。。兴奋了大半天，没办法搞下去吖 服务号又只能企业来做，那我只好等有钱了注册个公司搞这个了。 那最后的最后，就试一下发送消息是否成功把。 看样子是可以的，那还算是有点安慰，不枉这么长时间的辛苦。 看着这少得可怜的权限，以后怕是只能玩聊天机器人了。 总的来说，下面就要想点奇招才能完成自己的记账功能了。那么各位看官，请看下回分解。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（三）]]></title>
    <url>%2F2019%2F07%2F15%2Flearn-hexo-03%2F</url>
    <content type="text"><![CDATA[这里是对Hexo的第三次探究主要就是将博客的内容丰富了一下。 有兴趣的小伙伴可以看看前面两篇文章： Hexo搭建Github Pages个人博客（一） Hexo搭建Github Pages个人博客（二） 下面进入正文。 一、设置侧边栏社交链接打开主题配置，搜索social，下面已经用注释帮我们写好了很多链接的模板，直接套上自己的就可以了。下面放上我的配置： 1234567social: GitHub: https://github.com/godbobo || github E-Mail: mailto:bobobiubiubiubiu@gmail.com || envelope Weibo: https://weibo.com/p/1005056965815024/info || weibo Twitter: https://github.com/godbobo || twitter Zhihu: https://www.zhihu.com/people/zheng-bo-33-3/activities || university Instagram: https://www.instagram.com/bobobiubiubiubiu/ || instagram 唯一需要注意的就是知乎的图标font awesome上面没有，我找了个university替代，反正有个叫知乎大学的鬼东西（用都没用过） 下面是实现效果： 二、标签前面用图标表示默认情况下标签前面是一个#，换成标签图标那得有多高大上。 这个操作并不难，以前的版本可能还需要改模板代码，现在直接在主题配置文件改配置就行了！ 搜索tag-icon，将其改为： 1tag_icon: true 可以看到，标签前面已经有小图标了。 三、头像的折腾主题配置文件中有个avatar.ratated的属性，设置为true后，鼠标移动到头像上就会旋转360度。 想要更加高级的动画的话，可以用animate.css。首先在bootcdn找到它的link标签： 1&lt;link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet"&gt; 然后将其添加到\themes\next\layout\_partials\head\head.swig文件的末尾，在\themes\next\source\css\_common\components\sidebar\sidebar-author.styl中搜索avatar.rotated，可以发现刚刚旋转360度的代码实现，将其注释掉并换为animate.css中的动画即可。 12345678910111213if hexo-config('avatar.rotated') &#123; .site-author-image:hover &#123; -webkit-animation: bounceIn 1s; animation: bounceIn 1s; &#125; /*.site-author-image &#123; transition: transform 1.0s ease-out; &#125; .site-author-image:hover &#123; transform: rotateZ(360deg); &#125;*/&#125; 个人感觉这个折腾的意义不大，所以我最后还是没有给头像加动画，静静地待在那里不好么~ 若要尝试动画效果，可以去animate.css官网查看。 四、站点图标在主题配置文件中搜索favicon即可配置，图片资源放在主题目录下的source中，具体我就不尝试了，因为还没有找到一个好的图标，默认的就挺好看的。 五、鼠标点击特效鼠标在点击页面空白处的时候显示向上移动的心，想不想要想不想要？ 这个js文件比较好找，我自己也找了一个版本，效果还OK，就直接放到附录的鼠标点击特效文件里了，有需要的可以直接复制。 将heart.js文件放在/themes/next/source/js/目录中，找到/themes/next/layout/_layout.swig，搜索vendors.swig，在这一行的上面引入刚刚创建的js文件： 1&lt;script src="/js/heart.js"&gt;&lt;/script&gt; 放到文件末尾似乎和Next有冲突，放在这个位置我这里是没有问题的。 六、评论系统文章如果没有评论岂不是失去了灵魂？ 经过一天时间，leanCloud的实名认证终于下来了。进入控制台后，点击应用-创建应用，输入名字即可创建应用。 然后回到主题配置中，搜索valine，开启并填写自己的appid和appkey，最好把语言也修改一下，邮件通知我觉得就没有必要了，万一有一天我的博客很火把我吵得生活不能自理怎么办？ 重新运行即可看到效果： 当然，为了安全起见，还是要设置安全域名的： 七、留言板评论系统都有了，那留言板还不是手到擒来？ 在站点根目录键入命令： 1$ hexo new page message-board 打开/source/message-board/index.md，修改标题名： 1234---title: 留言板date: 2019-07-15 17:38:28--- 主题配置文件搜索menu，在下面添加一行代码： 12menu: 留言板: /message-board/ || inbox 我这里懒得去弄多语言了，直接把汉字作为key 重新运行，噔噔噔噔~ 八、浏览量功能知道你看过我，我会很开心的~ 打开leanCloud，依次点击应用 - 存储 - 创建Class，然后创建一个名为Couter的Class，并设置权限为无限制。 主题配置中，搜索valine，开启visitor功能即可。 这样只是开启了文章的浏览量统计功能，这当然不够，我要知道整个网站的访问量！ 主题配置中搜索busuanzi_count,设置为true即可。 怎么样，有没有吓一跳，这么多访客量！好吧，反正我是吓一跳，后面才明白我什么都没配它就给我显示了，那它应该记的是整个网址的访问量，而localhost？每天有多少人访问呢？ 哈哈哈哈哈哈哈 九、修改文章内链接样式蓝色链接看多了，黑色链接就不怎么习惯了。 打开themes\next\source\css\_common\components\post\post.styl，新增如下代码： 1234567891011/*修改链接样式*/.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 然后，就可以习惯了~ 十、显示公众号订阅我也是个想要订阅的人。 在微信公众平台的公众号设置中下载自己的二维码 然后把它放到站点的/source/uploads目录下，并重命名为wechat-qcode.jpg 主题配置中搜索wechat_subscriber，开启该功能并取消注释即可。 十一、打赏功能公众号都有了，不要点打赏怎么行？ 主题配置中搜索reward_settings,把下面的内容开启就行了，付款的图片当然也是需要的。 看到下面的比特币，好想把它开启，可是我并没有。。。 微信收款码获取方式： 聊天列表 - 收付款 - 二维码收款 - 保存收款码 我不想设置金额，我想要大大的惊喜。。（我想的可真多。。） 支付宝就比较简单，首页点击收钱就可以看到保存图片的按钮了。 实现效果如下： 千万不要开启reward_settings.animation！！！这是我的忠告~ 十二、腾讯公益404页面既然收了打赏，那就做点公益把 在/themes/next/source/目录下新建404页面，内容复制即可： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 不过奇怪的是我故意输错网址，却是一个空白的错误界面，非要我输入http://localhost:4000/404.html才会显示。不知道是出什么问题了。 附录1、鼠标点击特效文件heart.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 从jianhuax.com下载的(function(window,document,undefined)&#123;var hearts = [];window.requestAnimationFrame = (function()&#123;return window.requestAnimationFrame ||window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame ||window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function (callback)&#123;setTimeout(callback,1000/60);&#125;&#125;)();init();function init()&#123;css(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;");attachEvent();gameloop();&#125;function gameloop()&#123;for(var i=0;i&lt;hearts.length;i++)&#123;if(hearts[i].alpha &lt;=0)&#123;document.body.removeChild(hearts[i].el);hearts.splice(i,1);continue;&#125;hearts[i].y--;hearts[i].scale += 0.004;hearts[i].alpha -= 0.013;hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color;&#125;requestAnimationFrame(gameloop);&#125;function attachEvent()&#123;var old = typeof window.onclick==="function" &amp;&amp; window.onclick;window.onclick = function(event)&#123;old &amp;&amp; old();createHeart(event);&#125;&#125;function createHeart(event)&#123;var d = document.createElement("div");d.className = "heart";hearts.push(&#123;el : d,x : event.clientX - 5,y : event.clientY - 5,scale : 1,alpha : 1,color : randomColor()&#125;);document.body.appendChild(d);&#125;function css(css)&#123;var style = document.createElement("style");style.type="text/css";try&#123;style.appendChild(document.createTextNode(css));&#125;catch(ex)&#123;style.styleSheet.cssText = css;&#125;document.getElementsByTagName('head')[0].appendChild(style);&#125;function randomColor()&#123;return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")";&#125;&#125;)(window,document); 总结这次修改的大部分还都是可以直接配置的，但还没有结束，这不是我的博客的最终样子。它还需要做最后的蜕变！ 下一篇文章应该就是大量的自定义样式了，敬请期待。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（二）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-02%2F</url>
    <content type="text"><![CDATA[有点无聊，有点焦虑。 今天下午刚搞完第一波Hexo的部署，晚上又闲的没事干，那就继续捣鼓这个博客吧。 这是第二篇有关Hexo的文章，没有看过第一篇的可以去瞅瞅： Hexo搭建Github Pages个人博客（一） 一、背景动画相信大家在浏览网站时肯定见过网页背景随鼠标移动而变化的特效，以前以为很高大上，原来就是引一个js库的事。 这个功能仅适用于next主题，其他主题没有实验过。 打开/themes/next/_config.yml，搜索Animation Settings，第一个默认是开启的，看着可配置项有fadeIn之类的，猜想应该就是首页加载时各个部件的渐隐效果，那就不去动它了。 下面第二个叫pace的，看注释应该是进度条动画，那我觉得聊胜于无，开启就是了。下面就以这个库为例，讲一下怎么开启这个动画效果。 首先当然是要把pace.enable设置为true，单单这样是不够的，next主题并没有包含这个插件。如果就这样去运行，页面不会发生任何变化，而且控制台还会报404错误。 因此下一步就是去下载这个插件，next主题很贴心地把插件的地址放在了注释里面： 下载之后将其解压到/themes/next/sources/lib下面，然后将文件夹重命名为pace。 其他插件的导入方式类似，文件夹的名称要和配置文件中的名称保持一致。 导入成功之后就可以运行查看效果了。默认的minimal是浏览器顶部的一个蓝色进度条动画（页面加载时显示，普通情况下一条黑边）。 为了方便大家对比，也是解决这个无聊的周末夜晚，我一个一个把这些效果实验一下，供大家参考： 1、进度条动画主题描述 进度条下面的就都是背景动画了，官方文档说不能同时开启两个，但我试了一下，可以呀，只是不太好看而已~ 我也把所有的背景动画的特效试了一下，大家可以看截图选择自己看着舒服的。 2、背景动画特效展示 注意：下载的插件要把目录中的.github目录删掉，否则提交到github之后会找不到插件的路径。 二、百度统计详见https://theme-next.iissnan.com/third-party-services.html#analytics-baidu 配置成功后可以将项目发布在github上，然后检查是否安装正确： 三、谷歌站点收录详见https://theme-next.iissnan.com/third-party-services.html#google-webmaster-tools 刚刚配置的时候忘了截图了，现在已经找不到那个页面了。 不过只要注意在输入网址之后展开第一种验证方式就可以找到我们要的代码了。 四、本地搜索功能用第三方搜索还要注册还要收费，我只需要一个简单的搜索哦~ 详见https://theme-next.iissnan.com/third-party-services.html#local-search 搭建完成的效果也还OK 五、显示文章基本信息就是这种效果： 打开_config.yml配置站点： 12345symbols_count_time: symbols: true # 文章字数 time: true # 阅读时长 total_symbols: true # 所有文章总字数 total_time: true # 所有文章阅读中时长 打开/themes/next/_config.yml配置主题： 123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 wpm: 275 这样我们只是配置好了，但是插件还没有安装，下面就安装插件（网上看的一篇文章说next主题自带该插件，我信以为真，结果死活不显示统计数量，也不报错，还专门去github上下载该插件，结果最后才发现是要用npm安装的。。。） 1$ yarn add hexo-symbols-count-time 然后重新运行就可以了，底部也会出现整个站点的统计字数。 六、滚动时显示文章进度在主题配置中搜索back2top，然后你懂的~ 123456back2top: enable: true # 在侧边栏显示该控件 sidebar: true # 显示阅读进度 scrollpercent: true 然后效果如下： 在点击这个控件后就会返回顶部。 虽然说放在侧边栏与潜意识里的返回顶部按钮不同，且用百分比来装饰，让人误以为它只是用来显示而不能点击的。但胜在能与周围融为一体呀，我不管，我就要这么设置！ 七、生成网站地图第三步已经生成了谷歌的站点地图，这里的设置主要是针对百度的。 安装sitemap插件： 12$ yarn add hexo-generator-sitemap$ yarn add hexo-generator-baidu-sitemap 然后将站点配置文件中的url改为自己的github地址即可。 重新运行，从地址栏输入/baidusitemap.xml查看有没有生成。 似乎百度不能抓取github.io下的内容，那搞它有什么用，不搞了不搞了。 八、附录1、进度条动画主题描述 theme 效果描述 big-counter 页面右上角显示加载百分比（数字） bounce 页面右上角显示一个跳动的小球，逐渐远去并消失 barber-shop 整个页面都被进度条占满。。。 center-atom 页面中间显示一个小花，花朵中间显示加载百分比 center-circle 页面中间显示有百分比的圆，有一个翻转消失的动画 center-radar 页面中间一个雷达旋转的动画 center-simple 顾名思义，特别简单，页面中间一个进度条 corner-indicator 右上角一个切角，里面是转圈的线条 fill-left 从左到右填充页面，与barber-shop的区别是不会遮挡页面元素。（十分不推荐选这个） flat-top 页面上方显示一个较宽的进度条 flash 页面上方显示较细的进度条，同时右上角有个加载状态的圆。（整体感觉不错，我可能会选它） loading-bar 同样是页面中间一个进度条。。 mac-osx 页面产生波浪，顶部有进度条。。（不是太好看呀，感觉侮辱了macOs呀） material 页面中间一个透明的圆，里面是百分比。（挺清爽的感觉，还可以） minimal 页面上方显示一个很细的进度条 这些主题尝试下来，有一个共同的特点，在页面超过一屏的情况下，顶部会有一个黑色的进度条区域（不管这里会不会显示进度条），所以建议选择带有顶部进度条的主题。 2、背景动画特效展示canvas_nest: 就是红框中的那些线条，可以跟随鼠标移动。 three.three_waves: three共包含三种特效，因此配置文件中有两个开关都要打开才行。 效果挺震撼的，在页面空白区域比较多的时候看着特别爽。 three.canvas_lines: three.canvas_sphere: 这个动画动的幅度比较小，一般只能在页面切换时才能看到，平时就被文章给盖住了。 canvas_ribbon： 这个不会动，只会在鼠标点击时切换背景。 总的来说，这些动画都挺好看的，但是我就觉得有一种哗众取宠的感觉。我的注意力应该放在文字本身，你旁边动来动去的背景是想干啥？ 所以最终我选择了奢华低调有内涵的three.canvas_sphere 最后，还是想说一下，本来想搞一个评论系统的，结果leanCloud刚实名认证不能创建应用，其他的要么被墙要么收费，真是难为死我了。 说不得还得来个Hexo系列文章三呢。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（一）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-01%2F</url>
    <content type="text"><![CDATA[以前也了解过Hexo，但因为各种操作都需要敲命令，我这么懒，就是不想敲命令~所以就没怎么玩过这个。这些天无意间了解到有个Hexo的客户端，觉得可以试试了。 搭建完成之后文章列表只有一篇HelloWorld，不能忍不能忍，于是诞生了这篇文章。。。。 一、开启Github Pages在Github中创建一个新的仓库，仓库名字为：[你的用户名].github.io,例如我的用户名为godbobo，那么填写的名称就是godbobo.github.io 其他什么都不用填，点击创建。然后打开该项目的Settings: 在Github Pages这个栏目下点击Choose Theme。（我这个是已经创建好的，界面和没有创建过的是不一样的） 然后会跳转到选择主题的界面，直接默认第一个就好，反正后面还要换成Hexo的，选择之后在新的页面点击commit提交更改，一个崭新的Github Pages就建立好了，并且可以直接通过刚才的项目名进行访问。 一个账号只能有一个Github Pages可以通过这种方式访问。 到这一步，Github Pages就算是配置好了，下面就要开始激动人心的Hexo配置了。 二、安装Hexo首先全局安装Hexo脚手架： 1$ npm install hexo-cli -g 不知道为什么，我用yarn安装之后命令行没有hexo这个命令，万般无奈之下，我还是用了npm来安装。。。 用脚手架初始化博客目录： 123$ hexo init godbobo.github.io$ cd godbobo.github.io$ yarn 这里为了保险起见我没把项目放到中文目录下，直接在D盘建的文件夹。 生成并运行Hexo： 12345$ hexo clean# g 即 generate$ hexo g# s 即 serve$ hexo s 打开浏览器localhost:4000，即可看到效果： 注意到地址栏了吗？我已经把它部署到Github Pages上了，要实现这样的效果，请看下回分解~ 哦不，是下一步。 三、部署到Github Pages本地安装git以及如何连接到github的过程就不在这里讲了，下面直接开始正文： 安装hexo-deployer-git： 1$ yarn add hexo-deployer-git 在生成的项目中可以看到有一个_config.yml的文件，它是hexo的用户配置文件： 我们需要在这里配置自己刚刚创建的Github Pages地址，在该文件中搜索deploy或直接到文件末尾，做出类似下图的修改： 然后命令行中输入： 12# d 即 deploy$ hexo d 如果是第一次执行这个命令会让你输入github的账号密码，输入之后就能够发布到Github Pages上了。 四、个性化配置1、主题配置主题可以在https://hexo.io/themes上面找到自己满意的，不过这里我还是推荐朴素又不失内涵的next主题，它还有四个子主题可供选择。 将主题下载下来后(直接download zip就行了，用git命令感觉好慢)，解压并将目录重命名为next，然后放到hexo项目的/themes/下。 然后打开项目（站点）配置文件_config.yml，搜索theme或直接到文件末尾，将默认主题改为next即可。 然后重新运行hexo s就可以看到主题已经改变。 2、设置语言运行后发现整个页面都是英文，我大字都不识几个让我看英文？这可不行。 打开站点配置文件_config.yml及主题配置文件/themes/next/_config.yml，搜索到language，并将其改为zh-CN即可。 放上我更换主题以及换了语言之后的页面样子： 3、设置next子主题咦，你的next主题怎么和我的不一样？我也要我也要~ 在刚刚hexo-next的github页面可以看到这个主题下一共有四个子主题可供选择： 经过一番挑选，我觉得Gemini可能更养眼一点，打开主题配置文件/themes/next/_config.yml，搜索scheme，将其改为Gemini并重新生成页面即可。 4、支持RSS如果自己能读到自己的Feed，那该有多好~ 安装hexo-generator-feed插件： 1$ yarn add hexo-generator-feed 完毕！ 没错，就是这么简单！ 点击RSS链接，就会跳转到atom.xml页面，这就表示RSS已经成功生成了。 五、使用hexo-client说了大半天，花里胡哨，我要怎么不费吹灰之力新建文章编辑文章？ 打开https://github.com/gaoyoubo/hexo-client这个仓库，在README的最下方有最新版的下载地址，然后下载并安装。 首次进入需要设置hexo项目的目录，设置即可。 目前整个项目还很简陋，编辑文章时虽说有上传图片的功能，但却不能通过剪切板上传，还是很鸡肋的。所以现在这篇文章我就是通过Typora来编写，PicGo来上传图片的。 整个软件用起来并不复杂，稍微摸索以下就会了，只是添加标签和分类的功能肉眼是找不到的，需要在编辑文章时找到Front-matter，在这个里面配置标签、分类信息： 其中title为tags表示标签，categories表示分类，如果要添加多个，需要使用yml文件的数组格式。 附录在查找问题的过程中了解到Hexo的文档，以后要深入折腾的话可以参考一下： Hexo文档 Hexo-Next主题配置文档 一般来说，每次更改内容后，最好要依次执行以下下面三个命令： 1234# 这条不执行应该也可以，我这里每次改东西后不执行它也不会有问题$ hexo clean$ hexo g$ hexo s 最后，看hexo官网中的描述，还有好多花样自己没有尝试过，比如评论功能，所以后续应该会有第二篇写hexo的文章。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
