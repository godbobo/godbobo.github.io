<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（三）]]></title>
    <url>%2F2019%2F07%2F22%2Fwechat-account-03%2F</url>
    <content type="text"><![CDATA[上一篇文章基本上把技术上的实现都讲了一遍，证明实现这个功能是切实可行的。下面就对建好的服务雏形进行完善和增加功能。 先放这个系列的文章： 微信公众号制作记账功能（一） 微信公众号制作记账功能（二） 一、默认回复前面设置的默认回复就是简单的一句话，一点都不够智能，当然了，我再怎么改造，只要不用到聊天机器人这种功能，那就不会特别智能。但聊天机器人的API都是要收费的哎，而如果我用python在服务器上自己搭一个，那我真怕服务器会受不了这么大的压力。 那要怎么办呢？至少每次给用户的回复都不一样吧。这时我想到了hitokoto这个API，接口基本上没什么限制，每次都会返回一个新的句子，挺适合我的需求的。 下面新建/api/api.js，用于请求接口数据： 12345678910111213141516171819202122// 此处放置有关请求API接口的代码var request = require('request')// 获取一言数据const getHitokoto = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; request(&#123; method: 'GET', url: 'https://international.v1.hitokoto.cn/' &#125;, (err, res, body) =&gt; &#123; if (res) &#123; resolve(JSON.parse(body)) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;module.exports = &#123; getHitokoto&#125; 请求接口有了，下面就要使用这个接口，这里用到上篇文章说的链式调用处理信息。首先建立/service/default.js，这里同样要实现功能的分发，因为后面可能会为默认回复增加不同的功能。 1234567891011121314151617181920212223242526272829303132var db = require('./db')var api = require('../api/api')// 功能分发const doQuery = (payload) =&gt; &#123; if (payload.Content === '一言' || payload.Content === 'hitokoto') &#123; return returnHitokoto(payload, true) &#125; else &#123; return returnHitokoto(payload) &#125;&#125;// 获取一言const returnHitokoto = (&#123;FromUserName, CreateTime, Content&#125;, isTarget = false) =&gt; &#123; return api.getHitokoto().then(data =&gt; &#123; let tips = '' if (!isTarget) &#123; tips = '主人我太笨了，没有明白你的意思。不过我准备了一句话，你看你喜不喜欢？\n\n' // 构造未识别对话记录 const unknownWord = &#123; openid: FromUserName, content: Content, createTime: CreateTime &#125; db.unkonwnDb.insert(unknownWord) &#125; const msg = `$&#123;tips&#125;$&#123;data.hitokoto&#125;\n\nby $&#123;data.from&#125;` return msg &#125;)&#125;module.exports = doQuery 因为获取一句话同样是一个小功能，所以就先判断是否是专门获取一句话的，如果是的话，就不再添加我不懂我不懂之类的废话了，哈哈。 然后就是链式调用的实现了： 123456789101112131415// 普通文字消息 moneyManager.doQuery(json.xml).then(msg =&gt; &#123; if (msg) &#123; return msg &#125; else &#123; return defaultFilter(json.xml) &#125; &#125;).then(msg =&gt; &#123; // ... resbody = jParser.parse(tempBody) res.send(resbody) &#125;).catch(error =&gt; &#123; console.error(error) res.send('服务器发生异常，请联系微信号aqzscn解决') &#125;) 可以这么做的原因是如果上一个过滤器匹配到命令，它的返回值就不会为空，反之则会为空。这里当然是用的最笨的过滤器实现方式–手动添加，不过至少功能是实现了。 然后就可以尝试发送一条系统不懂的消息了： 怎么样？效果还可以吧 但这时我遇到一个问题，我请求hitokoto源是要消耗一段时间的，但微信服务器等不及呀，它就启动了它的三次重试机制。那我就只好增加一个过滤机制了，打开app.js，在系统启动时新增一个全局变量： 12// 定义缓存消息id的数组,防止重复响应global.tempMsg = [] 然后在/routes/wx.js中先判断是否是重复消息，不是的话才允许向下执行： 123456789101112131415161718192021222324// 因为系统还会请求其他服务器，返回可能会有延时，因此在这里判断并保存每个消息的openid和msgid(可能是在if语句外面，不过目前只是处理文字信息，先不考虑那么多了吧) let mIndex = -1 global.tempMsg.some((item, index) =&gt; &#123; if (item.openid === openid &amp;&amp; item.msgid === json.xml.MsgId) &#123; mIndex = index return true &#125; &#125;) if (mIndex &gt;= 0) &#123; res.send(resbody) return &#125; else &#123; mIndex = global.tempMsg.length // 添加到缓存 global.tempMsg.push(&#123; openid: openid, msgid: json.xml.MsgId &#125;) &#125;// ...// 在请求执行完之后，再将缓存中的数据删除global.tempMsg.splice(mIndex, 1) 这样就能防止重复对一个请求做出响应了。但不足的是代码实现不够优雅，后面应该增加一个前置过滤器来处理这种事情。 二、账单分页这个功能的实现就比较简单了，预期的实现效果是： 12345请求：账单回复：第一页账单请求：账单2回复：第二页账单 首先就是对功能分发的改造： 12// 匹配以账单开头的命令if (payload.Content.indexOf('账单') === 0) 查询账单时就是多了一个计算页数的过程，然后分页的逻辑nedb中已经有了，直接用就是了： 12345678910111213141516171819202122232425262728// 查询账单const queryBill = (&#123;FromUserName, CreateTime, Content&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let pageIndex = 0 if (Content.length &gt; 2) &#123; const temPage = parseInt(Content.replace('账单','')) if (temPage) &#123; pageIndex = temPage &#125;else &#123; res('') return &#125; &#125; if (pageIndex &gt; 0) &#123; pageIndex-- &#125; db.moneyDb.find(&#123;openid: FromUserName&#125;).sort(&#123;recordTime: -1&#125;).skip(pageIndex * config.billRows).limit(config.billRows).exec((err, docs) =&gt; &#123; let str = '' docs.forEach(item =&gt; &#123; const d = dateUtil.getNowSimpleFormatDate(new Date(item.recordTime * 1000)) const s = `[$&#123;d&#125;] $&#123;item.type&#125; $&#123;item.price&#125;元\n` str += s &#125;) const msg = str ? ('您的账单如下:\n' + str + '\n回复【账单+数字】可翻页') : '没有查询到账单哦~' res(msg) &#125;) &#125;)&#125; 然后就有了这种效果： 刚刚在正式的公众号看时间显示有点问题，待会儿看看怎么回事。 三、统计功能统计功能的预期实现效果： 12345请求：统计回复：当天收支情况请求：统计2回复：近2天收支情况 这个功能也是很简单就能实现的： 123456789101112131415161718192021222324252627282930313233343536373839// 匹配统计开头的命令fun doQuery:if (payload.Content.indexOf('统计') === 0) &#123; // 统计const tongji = (&#123;FromUserName, CreateTime, Content&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let dayIndex = 0 if (Content.length &gt; 2) &#123; const temday = parseInt(Content.replace('统计','')) if (temday &amp;&amp; temday &gt;= 0) &#123; dayIndex = temday &#125;else &#123; res('') return &#125; &#125; const now = new Date(CreateTime * 1000) now.setDate(now.getDate() - dayIndex) const d = dateUtil.getStartOfDay(now) db.moneyDb.find(&#123; recordTime: &#123; $gt: d.getTime()/1000 &#125;, openid: FromUserName&#125;, (err, docs) =&gt; &#123; // 定义结余、收入、支出 let remain = 0 let reward = 0 let cost = 0 docs.forEach(item =&gt; &#123; remain += item.yk * item.price if (item.yk &gt; 0) &#123; reward += item.price &#125; else &#123; cost += item.price &#125; &#125;) const dayTxt = dayIndex === 0 ? '当天' : `近$&#123;dayIndex&#125;天` const msg = `$&#123;dayTxt&#125;的收支情况如下：\n【结余】: $&#123;remain&#125; 元\n【收入】: $&#123;reward&#125; 元\n【支出】: $&#123;cost&#125; 元` res(msg) &#125;) &#125;)&#125; 然后实现效果如下： 四、固定开支我们每个月都会有固定开支，如工资、花呗、分期，这些固定的项目其实是不需要用户手动去输入的，系统完全可以帮用户做到。 预期效果： 12345678请求：月开销预设回复：请输入\n示例：【1工资2000】【2分期还款-500】\nTips:文字前的数字为每月几日，只支持1-28，不填写默认为1日==================30分钟内未回复则放弃当前指令==================请求：1工资1999回复：设置成功\n每月1日工资收入1999 要实现这样的效果，就要缓存用户上一步的指令，并且要知道指令的总步骤数量及当前进行到哪一步。 既然缓存了，就要有删除的步骤，一种方式是定义一个定时器，每隔一段时间清除失效的指令。另一种方式是在用户下一次请求时判断指令是否失效，如果失效就重新开始。 这里也要考虑到如果用户一直不发下个请求呢？难道服务器要一直缓存直到内存爆炸？所以定时器一定要有，但太频繁也不好，所以还是要在读取指令前判断用户之前的指令是否失效。 其实到现在这个步骤，整个后台应用就显得有点复杂了，我们必须要把过滤器的思路贯彻到底，重新改写响应逻辑，实现路由入口处的简洁。 首先，路由入口会收到两种消息类型：普通消息及事件推送，为了区分它们，我们先建立消息类型分发器msgTypeDispatcher.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const config = require('../config/index')const moneyManager = require('./money')const defaultManager = require('./default')const doDispatch = (payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 通过MsgType区分事件还是普通消息 if (payload.MsgType !== 'event') &#123; resolve(doNormalMsgPreFilter(payload)) &#125; else &#123; resolve(doEventMsgPreFilter(payload)) &#125; &#125;)&#125;// 普通消息的前置过滤器const doNormalMsgPreFilter = (payload) =&gt; &#123; // 判断系统是否正在处理该消息 let mIndex = -1 global.tempMsg.some((item, index) =&gt; &#123; if (item.openid === payload.FromUserName &amp;&amp; item.msgid === payload.MsgId) &#123; mIndex = index return true &#125; &#125;) if (mIndex &gt;= 0) &#123; // 如果正在处理，直接返回 return 'success' &#125; else &#123; mIndex = global.tempMsg.length // 添加到缓存，表示系统正在处理 global.tempMsg.push(&#123; openid: payload.FromUserName, msgid: payload.MsgId &#125;) &#125; if (payload.MsgType === 'text') &#123; return moneyManager.doQuery(payload).then(msg =&gt; &#123; if (msg) &#123; return msg &#125; else &#123; return defaultManager.doQuery(payload) &#125; &#125;).then(msg =&gt; &#123; return doNormalMsgSufFilter(mIndex, msg) &#125;) &#125; else &#123; return doNormalMsgSufFilter(mIndex, '不支持的消息类型') &#125;&#125;// 普通消息的后置过滤器const doNormalMsgSufFilter = (index, msg) =&gt; &#123; // 最终请求会走到这里，在这里从缓存中删除该消息 global.tempMsg.splice(index, 1) return msg&#125;// 事件消息的前置过滤器const doEventMsgPreFilter = (payload) =&gt; &#123; // 暂时不需要对事件有额外操作，判断事件类型后直接返回结果即可 if (payload.Event === 'subscribe') &#123; return subscribe() &#125; else if (payload.Event === 'unsubscribe') &#123; return unsubscribe() &#125; else &#123; return '不支持的事件类型' &#125;&#125;// 处理关注事件const subscribe = () =&gt; &#123; return config.banner&#125;// 处理取消关注事件const unsubscribe = () =&gt; &#123; return ''&#125;module.exports = doDispatch 将消息分发的逻辑抽取出来之后，/routes/wx.js接口的代码就变得非常简洁了： 12345678msgDiapatcher(json.xml).then(msg =&gt; &#123; tempBody.xml.Content = msg &#125;).catch(error =&gt; &#123; console.error(error) tempBody.xml.Content = '系统运行出错，请联系微信号aqzscn解决' &#125;).finally(() =&gt; &#123; res.send(jParser.parse(tempBody)) &#125;) 因为设定固定开支的步骤一共需要两步，那么我们就要保存上一步的状态，为了统一所有具有多个步骤的操作，新增一个步骤过滤器，在过滤器中可以直接执行相应步骤的代码。而且为了方便以后拓展，通过设定step来判断步骤执行到第几步。 123456789101112131415161718192021222324252627282930313233343536373839404142const presetManager = require('./preset')const garbageManager = require('./garbage')const doFilter = (payload) =&gt; &#123; // 判断用户是否正在执行上一步操作 let index = -1 global.stepMsg.some((item, idx) =&gt; &#123; if (item.openid === payload.FromUserName) &#123; index = idx return true &#125; &#125;) if (index &lt; 0) &#123; return '' &#125; else if (payload.Content === 'q') &#123; // 从缓存中移除该命令 global.stepMsg.splice(index, 1) return '已恢复正常模式' &#125; // 进入到指定的命令中 return new Promise((resolve, reject) =&gt; &#123; // 更新步骤消息的最后时间 global.stepMsg[index].time = Math.ceil(new Date().getTime() / 1000) switch (global.stepMsg[index].command) &#123; case 'setKz': const msg = presetManager.setKz(payload, global.stepMsg[index].step) // 从缓存中移除该命令 global.stepMsg.splice(index, 1) resolve(msg) break; case 'queryGarbage': resolve(garbageManager.queryStep(payload, global.stepMsg[index].step)) break; default: resolve('') &#125; &#125;)&#125;module.exports = &#123; doFilter&#125; 建立完成后在消息分发器中调用： 123456if (payload.MsgType === 'text' || payload.Content) &#123; // 首先执行步骤过滤器 const filterRes = stepFilter.doFilter(payload) if (filterRes) &#123; return filterRes &#125; 经过上面的处理，步骤消息就能到达指定的方法中，并且该方法也不必去管怎么去缓存当前步骤，怎么去删除缓存的事情，在我看来还算是一个较好的解决方案。下面把处理固定开支的代码放上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const db = require('./db')const doQuery = (payload) =&gt; &#123; if (payload.Content === '月收支预设') &#123; return setKz(payload) &#125; else if (payload.Content === '查询收支预设') &#123; return queryPreset(payload) &#125; else &#123; return '' &#125;&#125;// 预设开支const setKz = (&#123;FromUserName, CreateTime, Content&#125;, index = 0) =&gt; &#123; let msg = '' switch (index) &#123; case 0: // 将该用户的命令设置到缓存中 global.stepMsg.push(&#123; openid: FromUserName, step: 1, command: 'setKz', time: CreateTime &#125;) msg = '请输入\n示例1：【1工资2000】\n示例2：【2分期还款-500】\nTips:文字前的数字为每月几日，只支持1-28，不填写默认为1日' break; case 1: const dayReg = Content.match(/^\d&#123;1,2&#125;/) const titleReg = Content.match(/[^\d-]+/) const priceReg = Content.match(/-?\d+$/) if (titleReg &amp;&amp; priceReg) &#123; const day = dayReg ? parseInt(dayReg[0]) : 1 const title = titleReg[0] const price = parseInt(priceReg[0]) if (day &lt; 1 || day &gt; 28) &#123; msg = '为保证程序正常执行，只允许在每月1日到28日设置固定收支' &#125; else &#123; const kz = &#123; openid: FromUserName, day: day, title: title, money: price &#125; db.presetDb.insert(kz) msg = `设置成功！\n将于每月$&#123;day&#125;日自动添加账单【$&#123;title&#125; $&#123;price&#125;元】` &#125; &#125; else &#123; msg = '信息匹配失败，请检查是否符合【1工资2000】的格式' &#125; break; default: msg = '预设收支命令匹配失败' break; &#125; return msg&#125;// 查询收支预设const queryPreset = (&#123;FromUserName&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; db.presetDb.find(&#123;openid: FromUserName&#125;).sort(&#123;day: 1&#125;).exec((err, docs) =&gt; &#123; if (docs) &#123; let msg = '您的预设信息如下：\n' docs.forEach(item =&gt; &#123; const zy = item.money &gt; 0 ? '增加' : '扣除' const money = Math.abs(item.money) msg += `每月$&#123;item.day&#125;日 $&#123;zy&#125;【$&#123;item.title&#125;$&#123;money&#125;元】\n` &#125;) resolve(msg) &#125; else &#123; resolve('没有查询到您预设的收支\n回复【月收支预设】来设置一笔吧') &#125; &#125;) &#125;)&#125;module.exports = &#123; doQuery, setKz&#125; 最后的实现效果就是： 当然，这样只是实现了记录的功能，那么自动执行任务还没有做。我的预想是每晚3点定时去判断每个用户当天的收支预设信息，如果是当天，则向账单中添加记录。又因为项目中不可能只有这一个定时器，因此干脆一了百了，再做一个定时器管理的功能。 js中与定时有关的也就是setTimeout和setInterval了，而且现在需要做的也只是定时（整点）执行任务，那么我们就可以计算当前时间距离下一个整点还有多久，然后setTimeout到下一个整点（也可以是下下个整点，计算时间并相加即可），启动setInterval执行我们真正需要执行的任务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const presetTimer = require('./presetTimer')const config = require('../../config/index')const stepTimer = require('./stepTimer')let i = 1const timeDefine = config.taskTimerConfigconst init = () =&gt; &#123; // 测试功能 // test() // 一天的时间 毫秒数 const dayTimeStamp = 60 * 60 * 24 * 1000 // 月固定开支 startOfHourSchedule(timeDefine.presetTime, dayTimeStamp, presetTimer.doSchedule) // 定时清除缓存步骤消息 setInterval(() =&gt; &#123; stepTimer.doSchedule() &#125;, timeDefine.clearStepMsgTime);&#125;const test = () =&gt; &#123; presetTimer.doSchedule()&#125;/** * 定义在每天的某个小时执行的任务 * @param &#123;Number&#125; targetHour 目标起始时间 * @param &#123;Number&#125; intervalTime 循环时间 * @param &#123;Function&#125; fun 要执行的函数 */const startOfHourSchedule = (targetHour, intervalTime, fun) =&gt; &#123; if (targetHour &lt; 0 || targetHour &gt; 23) &#123; return &#125; const date = new Date() const nowtimeStamp = date.getTime() const nowHour = date.getHours() date.setHours(nowHour + 1) date.setMinutes(0) date.setSeconds(0) date.setMilliseconds(0) const nextHourTimeStamp = date.getTime() const diffTime = nextHourTimeStamp - nowtimeStamp const hour = 60 * 60 * 1000 let time = 0 if (nowHour &lt; targetHour ) &#123; // 当前时间小于预计时间 time = targetHour - nowHour -1 &#125; else &#123; time = 24 - (nowHour - targetHour + 1) &#125; console.log('将于' + Math.ceil((diffTime + hour * time) / 1000 / 60) + '分钟后执行定时任务' + i++) // 开启24个settiemout 0-23 分别对应下n个整点时间 setTimeout(() =&gt; &#123; fun() setInterval(() =&gt; &#123; fun() &#125;, intervalTime); &#125;, diffTime + hour * time);&#125;module.exports = &#123; init&#125; 这样写了之后，我们在项目的app.js中调用这个文件的init方法即可。 然后对于具体的固定收支添加账单的逻辑就比较简单了，就不再放到上面了，有兴趣的可以到我的github上看源码。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（二）]]></title>
    <url>%2F2019%2F07%2F17%2Fwechat-account-02%2F</url>
    <content type="text"><![CDATA[上次微信公众号制作记账功能（一）把nodejs的环境搭好了，并且可以简单地回复用户地信息了，那么接下来就要正式实现我们地功能了。 为了方便大家查看，也方便大家自己部署到公众号上，我把代码放到github上了，有兴趣可以去看一下。 一、功能分发因为我的订阅号的权限十分有限，那么基本上就只能靠用户的输入来猜测命令了，打开/routes/wx.js，找到处理普通文字消息的代码，进行如下修改： 12345678910111213// 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 moneyManager.doQuery(json.xml).then(msg =&gt; &#123; if (!msg) &#123; tempBody.xml.Content = '你好,我在努力进步中哦...' &#125; else &#123; tempBody.xml.Content = msg &#125; resbody = jParser.parse(tempBody) res.send(resbody) &#125;) &#125; 1、链式调用模块首先我的需求是不止有记账这一种功能，可以想见，那么多命令，如果都在wx.js里判断，那以后光找功能就要找好久。 我的思路是，将命令划分为几个模块，然后每个模块有自己专门的命令分发方法，每个模块处理完之后，wx.js就只负责将处理的结果返回给用户。 那么怎么判断这个命令属于哪个模块呢？我的想法是利用Promise的链式调用，如果上一个模块没有返回值，就执行下一个模块的命令分发，直至匹配到一个模块。类似下面这种方式： 12345678910111213function modelA() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;function modelB() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;modelA().then((res) =&gt; &#123; if (!res) &#123; return modelB() &#125; else &#123; return '' &#125;&#125;) 目前只定义了一个模块，暂时看不出效果，不过后面我会定义一个默认模块，即若前面的模块都没有匹配到命令时，进入该模块返回一个默认的回复信息。 2、命令识别 人工智能离用户很近，但离开发者很远~ 首先，记账模块有三个子功能：记账、查询账单、统计，而且记账时我想让用户直接输入，因为输入就已经够麻烦了，不能再增加步骤了。 那么在分发的入口就先去匹配固定的命令，如果没有匹配到，再去匹配记账这个随机性很大的命令。而在匹配记账的过程中，我用的是比较笨的方法，定义一个用户可能会输入的数组，然后再去匹配。 下面放上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// /service/money.jsconst keywords = [ '吃饭', '购物', '工资', '日用', '交通', '零食', '运动', '娱乐', '通讯', '服饰', '住房', '居家', '社交', '旅行', '烟酒', '数码', '医疗', '书籍', '礼物', '快递', '水果', '蔬菜', '亲友', '彩票', '捐赠', '维修', '办公', '宠物', '学习', '汽车', '美容', '兼职', '理财', '礼金', '早餐', '午餐', '晚餐', '早饭', '午饭', '晚饭']const mt = [-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1]// 功能分发const doQuery = (payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 在此处比较数量是否一致，防止输入时出错 if (process.env.NODE_ENV === 'development') &#123; console.log('记账关键词与盈亏数量对比：', keywords.length, mt.length) &#125; if (payload.Content === '账单') &#123; queryBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else if (payload.Content === '统计') &#123; tongji(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else &#123; // 记账 addBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; &#125;)&#125;// 记账const addBill = (&#123;FromUserName, CreateTime, Content, MsgId&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let index = -1 keywords.some((item, idx) =&gt; &#123; if (Content.indexOf(item) &gt;= 0) &#123; index = idx return true &#125; &#125;) if (index &gt;= 0) &#123; const price = parseFloat(Content.replace(keywords[index], '')) if (!price) &#123; res('错误提示：未输入金额或金额格式错误\n所属模块：[记账]') &#125; else &#123; const tempTxt = mt[index] &gt; 0 ? '收入' : '支出' retMsg = `记录成功！\n$&#123;keywords[index]&#125; $&#123;tempTxt&#125; $&#123;price&#125;元` res(retMsg) &#125; &#125; else &#123; res('') &#125; &#125;)&#125;// 查询账单const queryBill = (&#123;FromUserName, CreateTime&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; var str = '您的账单如下:\n' res(str) &#125;) &#125;)&#125;// 统计const tongji = () =&gt; &#123;&#125;module.exports = &#123; doQuery&#125; 我将模块都放在service目录，以便统一管理。上面的代码Promise用得总感觉有点别扭，但还是可以正常运行的，等哪天开窍了估计就能写出更优雅的代码了。 二、数据存储记账记账，如果不存下来，那还叫什么记账？ 1、简单介绍nodejs在数据存储方面的选择其实有很多种，但限于我的服务器很菜，我只能选择基于文件系统的数据库了，那就排除掉MySql、Redis。然后我听人推荐LevelDb，好家伙，感觉比Redis难用多了，我就想简单地放个对象数组，放了大半天都失败了，还读取不到！然后又把目光放到Sqlite3上面，又是一个好家伙，我还要在代码中定义数据结构，这还是我印象中地js吗？ 就在我彷徨不所知时，一道闪电击中了我的脑袋，nedb!赶忙在github上搜索，竟然搜到了这个数据库，然后赶紧试试能不能用，好不好用。用过之后，我只有一个感觉，丝滑~ 我就稍微介绍一下它吧（太丝滑了，必须得多说几句啊），nedb是mongoDb的一个子集，mongoDb相信大家会有所耳闻，而子集，就是将mongoDb的常用操作抽取出来了，所以用着是真的顺手。啥也不说了，先放链接： https://github.com/louischatriot/nedb 这是我生成的数据库文件，没错，只有一个文件，文件内容肉眼可读！一个字，强啊。 2、应用在nedb中，一个表就是一个文件（个人肤浅见解），因此管理表的任务就交给我们了。 我的做法是专门用一个文件/service/db.js去管理数据库信息: 12345678var Datastore = require('nedb')// 生成nedb的实例并自动打开数据库var moneyDb = new Datastore(&#123; filename: 'moneyLog.db', autoload: true &#125;)// 这里我考虑到项目中不止会用到一张表，就用这种方式导出多个nedb的操作对象module.exports = &#123; moneyDb&#125; 然后在/service/money.js中的用法就是： 123456789101112131415161718192021222324// 构造账单记录const bill = &#123; msgId: MsgId, type: keywords[index], yk: mt[index], price: price, openid: FromUserName, recordTime: CreateTime&#125;// 没错，就这么简单就插入了db.moneyDb.insert(bill)// ...var str = '您的账单如下:\n'// 查询也很简单，还可以排序，具体的可以看github上的文档db.moneyDb.find(&#123;openid: FromUserName&#125;).sort(&#123;recordTime: -1&#125;).exec((err, docs) =&gt; &#123; docs.forEach(item =&gt; &#123; const d = dateUtil.getNowSimpleFormatDate(new Date(CreateTime * 1000)) const s = `[$&#123;d&#125;] $&#123;item.type&#125; $&#123;item.price&#125;元\n` str += s&#125;)res(str)&#125;) 做到这一步之后，就可以运行查看效果了。 可以看到，这里我专门取消关注后再新增的记录，一样可以获取到以前的记录。 当然，这个功能还有许多地方要完善，比如支持查询啦，支持翻页啦，这些就放到下次再讲吧。 三、自适应环境这个标题实在想不到既简短又直击要害的了… 通常情况下，我们的开发环境和生产环境的配置信息是有所不同的，那我们每次切换环境都要重新手动修改配置文件吗？ 这当然不行。 以前这种区分开发环境和生产环境的功能也用过，不过都是别人写好的模板，这次总算自己实现了一下。 原理很简单，我们的系统都是可以设置环境变量的，而我们平常运行项目执行的yarn start或者npm start其实都是执行的package.json中配置的scripts: {&quot;start&quot;: &quot;node xxxx.js&quot;}这种命令。那我们就可以在执行这个命令之前先将系统的环境变量设为开发环境或生产环境，然后程序里读取当前是开发环境还是生产环境，然后加载不同的配置文件就可以了。 首先，了解一下设置环境变量的方式： 1234# windows系统set NODE_ENV=development# Linux/Mac系统export NODE_ENV=development 不同操作系统的命令不一样，这确实给我造成了不小的困扰，但也只能在不同的系统上再手动改一下了。 然后修改packages.json： 12345// 开发环境是windows，因此先设置为windows的命令"scripts": &#123; "dev": "set NODE_ENV=development&amp;&amp; nodemon ./bin/www", "prod": "set NODE_ENV=production&amp;&amp; nodemon ./bin/www" &#125;, 上面用到了&amp;&amp;用于在同一行内区分两条命令，同时要注意的是，&amp;&amp;前面不能用空格分开！，这导致我一直无法区分开发环境和生产环境。 这样修改之后，在js代码中，就可以通过以下代码进行判断： 1if (process.env.NODE_ENV === 'development')&#123;&#125; 这样设置完成基本上就可以了，但因为我想把代码放到github上让大家参考，又不能把自己的密钥之类的放在上面，那么我就还需要想点褶子。 首先，项目中要将开发环境和生产环境的配置文件分开，同时要将私密信息单独创建一个文件，还要有一个文件专门放不会变的配置信息。因此，我的config文件夹就变成了这个样子： 其中*.self.js是我配置私密信息的地方，然后在dev.js中获取，最后在index.js中判断环境后获取对应的配置信息。然后，我再将*.self.js的文件设置为忽略上传就可以了。不过这样的话我又要去写README.md了。。。 下面附上index.js中区分环境的代码： 12345678910const devConfig = require('./dev')const prodConfig = require('./prod')// 区分开发环境和生产环境const env = process.env.NODE_ENV || 'development'var isDev = env === 'development'// 每次启动时会打印当前运行环境，更好的提醒使用者console.log('当前运行环境：',env)const appid = isDev ? devConfig.appid : prodConfig.appid 总结在做这个记账功能的时候，数据库的选择真的是卡了我好长时间，还好有那一道闪电~ 最后，希望大家可以关注一下我的公众号，体验一下微信记账的感觉~]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（一）]]></title>
    <url>%2F2019%2F07%2F16%2Fwechat-account-01%2F</url>
    <content type="text"><![CDATA[一直想写一个记账软件，但界面的设计真让我头大。这不，刚买了个服务器，那用这个当后台存储，微信公众号菜单作为界面交互，练个手？ 我的服务器只有512M内存，10G硬盘，跑Java就别想了。刚刚看自己的SpringBoot应用跑在自己电脑上就占了479M内存，这还没说Mysql呢，服务器还挂着SSR，没办法，不能用Java来开发了。 从网上查找Java、Python、nodejs、php的性能比较，都说nodejs性能最好，那就玩nodejs喽（当然我在python上纠结过，不过nodejs一是比较熟悉，而是自己想实现的聊天机器人可以通过API调用来实现，也就是python能做的nodejs都有替代方案，性能又好，那必须选它了） 一、环境搭建1、安装express这里就参考Express官方文档一步步操作的。 不过官方文档稍微有点啰嗦，说了前一步，结果后面告诉你前面的方法太Low了。所以这里我就把关键部分再描述一遍。 全局安装Express脚手架： 1$ yarn global add express-generator 创建项目： 1$ express --view=pug myapp 如果不输入项目名[myapp]，就会在当前目录生成各种文件。 如果不输入–view=pug，控制台会报错jade模板不能用之类的事，我怂，我输入。 进入项目，安装依赖并运行： 123$ cd myapp$ yarn$ yarn start 2、控制台输出端口信息这时控制台是很干巴巴的，对于就喜欢看控制台不停输出信息的Java开发者来说，难受吖。 打开/bin/www，找到末尾的onListening方法，这样进行改动： 12345function onListening() &#123; // ... debug('Listening on ' + bind); console.log('Listening on ' + bind)&#125; 然后控制台就会输出Listening on port 3000了，舒服了舒服了。 3、代码自动刷新习惯了vuejs的自动刷新，每每改完文件还要Ctrl + C、Y、⬆是真的痛苦。还好我有~ nodemon 首先全局安装nodemon： 1$ yarn global add nodemon 打开package.json，修改scripts： 1"start": "nodemon ./bin/www" 依旧是原来的配方，yarn start启动项目，舒服了舒服了。 二、与微信服务器“配对”申请微信公众号之后，在开发者工具中找到公众平台测试账号，填写接口配置信息。 当然现在点击保存肯定是提示配置失败的，下面我们开始配置自己的Express服务器来正确响应微信服务器的消息。 在/routes/目录下新建wx.js文件，直接把user.js的内容复制过来。打开app.js，仿照user.js导入路由的方式： 12var wxRouter = require('./routes/wx')app.use('/cqm/wx', wxRouter) 然后在测试号的页面再次点击保存，这次不是为了配对成功，而是查看接口会传来什么参数，然后我们需要验证这是微信服务器发来的消息。 此时需要安装一个模块用来加密信息： 1$ yarn add jssha --dev 然后就是根据传来的参数验证信息，成功后把echostr字段返回给微信服务器。 12345678910111213141516171819202122232425// 微信服务器认证router.get('/', function(req, res, next) &#123; // 1 获取微信服务器请求参数 var signature = req.query.signature // 加密签名 var timestamp = req.query.timestamp // 时间戳 var nonce = req.query.nonce // 随机数 var echostr = req.query.echostr // 随机字符串 console.log(`接收到微信服务器认证请求`) // 2 将token timestamp nonce 按字典序排序 var array = [config.token, timestamp, nonce] array.sort() // 3 将参数加密 var tempStr = array.join('') var shaObj = new jsSHA('SHA-1', 'TEXT') shaObj.update(tempStr) var scyptoStr = shaObj.getHash('HEX') // 4 将加密后的字符串与signature对比，相同则表示验证成功 if (signature === scyptoStr) &#123; console.log('验证成功') res.send(echostr) &#125; else &#123; console.log('验证失败') res.send('验证失败') &#125;&#125;); 保存后在微信测试号里再次保存配置信息，就可以保存成功了。 我在测试时用到了一个公司的反向代理工具，把自己电脑映射到服务器的指定网址了。其实原理是差不多的，你只要有一台自己的服务器，在上面配置nginx反向代理，映射到你本机，就可以实现开发环境与微信服务器联调了。 三、响应用户发来的消息微信服务器会把用户发送的消息以post方式发送到刚刚验证的接口，同样的，我们需要正确回复微信服务器。 1234567891011121314// 微信服务器消息接收router.post('/', (req, res, next) =&gt; &#123; var signature = req.query.signature var timestamp = req.query.timestamp var nonce = req.query.nonce var openid = req.query.openid // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`)&#125;) 然后手机关注自己的测试号并随便发送一个消息，就可以看到自己的回复了： 还是很神奇的，不过到这一步只是简单实现了回复消息，实际上我们没有识别用户的输入，也没有做其他复杂的机制，比如5秒内无法回复时要先返回success告知微信服务器我收到消息了，还要应对微信服务器的3次重试机制。 下面就先实现识别用户发送消息的功能： 在nodejs中，接收post请求参数的方式和Java的不一样，Java直接就可以获取了，而nodejs还要等待数据传输完毕。因此我们就需要先监听数据传输事件，并将数据保存到一个buffer中，然后监听接收完成的事件，接着才是处理数据及返回消息的步骤： 12345678910111213141516 var buffer = []// 监听data事件 用于接收数据 req.on('data', data =&gt; &#123; buffer.push(data) &#125;) // 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; console.log(Buffer.concat(buffer).toString('utf-8')) // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`) &#125;) 用惯了Java的我，发现不能直接获取post请求参数之后，我还傻傻地去找转换工具，结果看到了一个body-parser，用了之后发现没效果。算了算了，入乡随俗。 这样修改之后，就可以获取到用户发来的消息了： 下面就是解析信息了（看到请求消息才明白官方文档的![CDATA[]]是不能省略的，但竟然识别出了我的回复，强吖） 安装fast-xml-parser： 1$ yarn add fast-xml-parser 解析xml数据： 12345var xmlParser = require('fast-xml-parser')var xml = Buffer.concat(buffer).toString('utf-8')console.log(xml)var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml))console.log(json) 然后，我们熟悉的json就又回来啦： 四、自定义菜单被动回复我们现在可以做到了，下面就是要主动向微信服务器发送消息告诉它我们要设置菜单项！ 1、获取access_token与微信服务器的很多交互都需要用到access_token的，而access_token有7200秒（2小时）的有效期，那我们需要做的，就是在项目启动后获取一次access_token，并且启动一个定时器，每隔7000秒重新获取一次。 因为习惯了vue.js的开发模式，我这里在项目根目录下新建了/api/wx.js文件，专门负责发送微信请求。在请求库的选择上，因为我们现在是服务端，不可能只请求一个域名，那么用axios设置baseUrl的方式就不是特别合适，就直接用request库来发送请求就好了，每次请求都定义一下url，也没有特别麻烦，而且我看很多人都这么用，那应该不会错了。 安装request和querystring： 12$ yarn add request$ yarn add querystring 其中querystring是将json数据转换为url请求参数的库 然后开始编写请求方法： 1234567891011121314151617181920212223242526var config = require('../config/index')var qs = require('querystring')var request = require('request')// 获取AccessTokenconst getAccessToken = () =&gt; &#123; const params = &#123; 'grant_type': 'client_credential', 'appid': config.appid, 'secret': config.appsecret &#125; const url = `$&#123;config.wxUrl&#125;cgi-bin/token?$&#123;qs.stringify(params)&#125;` // console.log('getAccessToken请求地址为', url) return new Promise((resolve, reject) =&gt; &#123; request(&#123; method: 'GET', url: url &#125;, (err, res, body) =&gt; &#123; if (res) &#123; resolve(JSON.parse(body)) &#125;else&#123; reject(err) &#125; &#125;) &#125;)&#125; 打开/bin/www： 1234567891011121314151617var wxAPI = require('../api/wx')function onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000);&#125; 然后重新运行项目，就会在控制台打印出我们获取到的token，这里将access_token保存到了global全局对象中，方便其他地方使用。 nodemon好像不会监听www文件的修改，所以需要我们重新启动服务。 2、配置自定义菜单有了access_token，我们就可以放心地向微信服务器发送请求了。但在此之前，我们还没有定义自己的菜单呢。我这里将菜单保存为json格式，同时也是熟悉一下文件操作： /config/wxmenus.json 12345678910111213141516171819202122232425262728293031323334&#123; "button": [ &#123; "name": "记账", "sub_button": [ &#123; "type": "click", "name": "收入", "key": "add_money" &#125;, &#123; "type": "click", "name": "支出", "key": "sub_money" &#125;, &#123; "type": "click", "name": "账单", "key": "bill" &#125;, &#123; "type": "click", "name": "预算", "key": "wish" &#125; ] &#125;, &#123; "type": "click", "name": "待办", "key": "todo_list" &#125; ]&#125; 因为我要做记账的功能，所以就预先把菜单定义好，后面也省得再去调整了。 首先尝试一下能否正确读取出json文件： /api/wx.js 12345678910111213141516var fs = require('fs')// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 var m = JSON.parse(data.toString()) resolve(m) &#125; &#125;) &#125;)&#125; 注意这里的文件路径是基于项目路径而不是wx.js当前路径。 然后同样在www中的onListening添加调用： 123456// 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) 重启服务就会在控制台看到我们要的结果： 下面继续修改wx.js，将我们配置的菜单发送给微信服务器。 1234567891011121314151617181920212223242526// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 const menuData = data.toString() const url = `$&#123;config.wxUrl&#125;cgi-bin/menu/create?access_token=$&#123;global.access_token&#125;` request(&#123; method: 'POST', url: url, form: menuData &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(JSON.parse(body)) &#125; &#125;) &#125; &#125;) &#125;)&#125; 改完这个之后还不够，因为这里用到了access_token，我们必须保证在发送菜单的这个请求时我们已经获取到了access_token，那么我们就要修改www文件： 1234567891011121314151617181920212223242526var isInit = falsefunction onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) if (!isInit) &#123; // 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) isInit = true &#125; &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000)&#125; 这里就是通过一个标志位来判断获取access_token后是否还需要发送设置菜单的请求。然后取消关注测试号，再重新关注一下： 可以看到我们的菜单已经设置生效了。在这个过程中我还注意到控制台还接收到了用户关注和取消关注事件的请求，这表明这个post接口不只是用来接收消息的，应该还有其他用处。 3、接收菜单点击事件到这一步就要参考微信官方文档给的事件类型了，然后在/routes/wx.js中根据不同类型做出不同回应即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; var xml = Buffer.concat(buffer).toString('utf-8') var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml)) console.log(json) // 定义返回消息 var resbody = 'success' var tempBody = &#123; xml: &#123; ToUserName: json.xml.FromUserName, FromUserName: json.xml.ToUserName, CreateTime: timestamp, MsgType: 'text' &#125; &#125; var jParser = new xmlParser.j2xParser() // 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 tempBody.xml.Content = '你好,我在努力进步中哦...' resbody = jParser.parse(tempBody) &#125; else if (json.xml.MsgType === 'event') &#123; // 事件类型 一共有六种事件1 关注/取消关注事件 2 扫描带参数二维码事件 3 上报地理位置事件 4 自定义菜单事件 5 点击菜单拉取消息时的事件推送 6 点击菜单跳转链接时的事件推送 if (json.xml.Event === 'CLICK') &#123; // 自定义菜单事件 tempBody.xml.Content = `您点击了$&#123;json.xml.EventKey&#125;` resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'subscribe') &#123; // 关注事件 tempBody.xml.Content = '欢迎关注' resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'unsubscribe') &#123; // 取消关注事件 该事件不能给用户发送消息 resbody = '' &#125; else if (json.xml.Event === 'LOCATION') &#123; // 上报地理位置事件 暂时不考虑 resbody = '' &#125; else &#123; // 其他事件有点复杂，先不做处理 &#125; &#125; res.send(resbody) &#125;) 然后取消关注测试号再重新关注，将刚刚的几种事件类型试一下，看看会不会做出正确的响应即可。 五、部署到正式的公众号我的服务器是CentOS，并且是刚刚创建的，一片空白，那现在就需要安装nodejs环境和ftp服务了。 以前自己在Linux下安装过ftp，不过失败了。但这次！看了leoxuan的CentOS7 FTP安装与配置后，我成功了！ 大家在按着这个教程来的时候用户名一定要弄对，上面截图中的一个错误就是我直接复制文章中的代码忽略了用户名才出错的。 传输文件时我这里一直无法传输，按文章中说的关闭SeLinux也不行，更改权限775不起作用，最后索性改为777才可以成功上传。 下面，在app.js中修改我们的代码，不再监听/cqm/wx了，这次翻身做主人，直接监听/wx！ 然后打包（压缩）项目，上传到服务器。 下面需要在服务器安装nodejs，这里我是参照CentOS7.5安装nodejs进行安装的。我选择的是第二种方法，毕竟以后全局安装插件就可以省点事了。 不过编译真的好慢啊，我写完这行字的时候它还没有编译好。。。 上面的安装对我来说完全不起作用，又参考了一篇文章在CentOS 7上安装Node.js的4种方法（包含npm）,用其中的第四种方法，终于是成功了，下面我把命令粘贴一下，方便以后使用。 123456curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bashsource ~/.bash_profilenvm list-remotenvm install v10.16.0node -vnpm 然后再安装我们需要的各种依赖，就可以使用yarn start启动项目了。 但我们的服务是放在3000端口的，我们需要配置nginx服务器的反向代理。 1234567server &#123; listen 80; server_name aqzscn.com; location / &#123; proxy_pass http://127.0.0.1:3000/wx; &#125;&#125; 经过一番配置，运行，然后在微信公众号上配置自己的服务器信息（不要忘记修改Appid和Secret为公众号的），然后你就会发现，还有一大堆问题要解决。 其中ip不在白名单的问题好解决，直接在公众号上设置就好了，但下面的问题是真的没办法解决。 没有权限。。好忧桑。。兴奋了大半天，没办法搞下去吖 服务号又只能企业来做，那我只好等有钱了注册个公司搞这个了。 那最后的最后，就试一下发送消息是否成功把。 看样子是可以的，那还算是有点安慰，不枉这么长时间的辛苦。 看着这少得可怜的权限，以后怕是只能玩聊天机器人了。 总的来说，下面就要想点奇招才能完成自己的记账功能了。那么各位看官，请看下回分解。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（三）]]></title>
    <url>%2F2019%2F07%2F15%2Flearn-hexo-03%2F</url>
    <content type="text"><![CDATA[这里是对Hexo的第三次探究主要就是将博客的内容丰富了一下。 有兴趣的小伙伴可以看看前面两篇文章： Hexo搭建Github Pages个人博客（一） Hexo搭建Github Pages个人博客（二） 下面进入正文。 一、设置侧边栏社交链接打开主题配置，搜索social，下面已经用注释帮我们写好了很多链接的模板，直接套上自己的就可以了。下面放上我的配置： 1234567social: GitHub: https://github.com/godbobo || github E-Mail: mailto:bobobiubiubiubiu@gmail.com || envelope Weibo: https://weibo.com/p/1005056965815024/info || weibo Twitter: https://github.com/godbobo || twitter Zhihu: https://www.zhihu.com/people/zheng-bo-33-3/activities || university Instagram: https://www.instagram.com/bobobiubiubiubiu/ || instagram 唯一需要注意的就是知乎的图标font awesome上面没有，我找了个university替代，反正有个叫知乎大学的鬼东西（用都没用过） 下面是实现效果： 二、标签前面用图标表示默认情况下标签前面是一个#，换成标签图标那得有多高大上。 这个操作并不难，以前的版本可能还需要改模板代码，现在直接在主题配置文件改配置就行了！ 搜索tag-icon，将其改为： 1tag_icon: true 可以看到，标签前面已经有小图标了。 三、头像的折腾主题配置文件中有个avatar.ratated的属性，设置为true后，鼠标移动到头像上就会旋转360度。 想要更加高级的动画的话，可以用animate.css。首先在bootcdn找到它的link标签： 1&lt;link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet"&gt; 然后将其添加到\themes\next\layout\_partials\head\head.swig文件的末尾，在\themes\next\source\css\_common\components\sidebar\sidebar-author.styl中搜索avatar.rotated，可以发现刚刚旋转360度的代码实现，将其注释掉并换为animate.css中的动画即可。 12345678910111213if hexo-config('avatar.rotated') &#123; .site-author-image:hover &#123; -webkit-animation: bounceIn 1s; animation: bounceIn 1s; &#125; /*.site-author-image &#123; transition: transform 1.0s ease-out; &#125; .site-author-image:hover &#123; transform: rotateZ(360deg); &#125;*/&#125; 个人感觉这个折腾的意义不大，所以我最后还是没有给头像加动画，静静地待在那里不好么~ 若要尝试动画效果，可以去animate.css官网查看。 四、站点图标在主题配置文件中搜索favicon即可配置，图片资源放在主题目录下的source中，具体我就不尝试了，因为还没有找到一个好的图标，默认的就挺好看的。 五、鼠标点击特效鼠标在点击页面空白处的时候显示向上移动的心，想不想要想不想要？ 这个js文件比较好找，我自己也找了一个版本，效果还OK，就直接放到附录的鼠标点击特效文件里了，有需要的可以直接复制。 将heart.js文件放在/themes/next/source/js/目录中，找到/themes/next/layout/_layout.swig，搜索vendors.swig，在这一行的上面引入刚刚创建的js文件： 1&lt;script src="/js/heart.js"&gt;&lt;/script&gt; 放到文件末尾似乎和Next有冲突，放在这个位置我这里是没有问题的。 六、评论系统文章如果没有评论岂不是失去了灵魂？ 经过一天时间，leanCloud的实名认证终于下来了。进入控制台后，点击应用-创建应用，输入名字即可创建应用。 然后回到主题配置中，搜索valine，开启并填写自己的appid和appkey，最好把语言也修改一下，邮件通知我觉得就没有必要了，万一有一天我的博客很火把我吵得生活不能自理怎么办？ 重新运行即可看到效果： 当然，为了安全起见，还是要设置安全域名的： 七、留言板评论系统都有了，那留言板还不是手到擒来？ 在站点根目录键入命令： 1$ hexo new page message-board 打开/source/message-board/index.md，修改标题名： 1234---title: 留言板date: 2019-07-15 17:38:28--- 主题配置文件搜索menu，在下面添加一行代码： 12menu: 留言板: /message-board/ || inbox 我这里懒得去弄多语言了，直接把汉字作为key 重新运行，噔噔噔噔~ 八、浏览量功能知道你看过我，我会很开心的~ 打开leanCloud，依次点击应用 - 存储 - 创建Class，然后创建一个名为Couter的Class，并设置权限为无限制。 主题配置中，搜索valine，开启visitor功能即可。 这样只是开启了文章的浏览量统计功能，这当然不够，我要知道整个网站的访问量！ 主题配置中搜索busuanzi_count,设置为true即可。 怎么样，有没有吓一跳，这么多访客量！好吧，反正我是吓一跳，后面才明白我什么都没配它就给我显示了，那它应该记的是整个网址的访问量，而localhost？每天有多少人访问呢？ 哈哈哈哈哈哈哈 九、修改文章内链接样式蓝色链接看多了，黑色链接就不怎么习惯了。 打开themes\next\source\css\_common\components\post\post.styl，新增如下代码： 1234567891011/*修改链接样式*/.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 然后，就可以习惯了~ 十、显示公众号订阅我也是个想要订阅的人。 在微信公众平台的公众号设置中下载自己的二维码 然后把它放到站点的/source/uploads目录下，并重命名为wechat-qcode.jpg 主题配置中搜索wechat_subscriber，开启该功能并取消注释即可。 十一、打赏功能公众号都有了，不要点打赏怎么行？ 主题配置中搜索reward_settings,把下面的内容开启就行了，付款的图片当然也是需要的。 看到下面的比特币，好想把它开启，可是我并没有。。。 微信收款码获取方式： 聊天列表 - 收付款 - 二维码收款 - 保存收款码 我不想设置金额，我想要大大的惊喜。。（我想的可真多。。） 支付宝就比较简单，首页点击收钱就可以看到保存图片的按钮了。 实现效果如下： 千万不要开启reward_settings.animation！！！这是我的忠告~ 十二、腾讯公益404页面既然收了打赏，那就做点公益把 在/themes/next/source/目录下新建404页面，内容复制即可： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 不过奇怪的是我故意输错网址，却是一个空白的错误界面，非要我输入http://localhost:4000/404.html才会显示。不知道是出什么问题了。 附录1、鼠标点击特效文件heart.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 从jianhuax.com下载的(function(window,document,undefined)&#123;var hearts = [];window.requestAnimationFrame = (function()&#123;return window.requestAnimationFrame ||window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame ||window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function (callback)&#123;setTimeout(callback,1000/60);&#125;&#125;)();init();function init()&#123;css(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;");attachEvent();gameloop();&#125;function gameloop()&#123;for(var i=0;i&lt;hearts.length;i++)&#123;if(hearts[i].alpha &lt;=0)&#123;document.body.removeChild(hearts[i].el);hearts.splice(i,1);continue;&#125;hearts[i].y--;hearts[i].scale += 0.004;hearts[i].alpha -= 0.013;hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color;&#125;requestAnimationFrame(gameloop);&#125;function attachEvent()&#123;var old = typeof window.onclick==="function" &amp;&amp; window.onclick;window.onclick = function(event)&#123;old &amp;&amp; old();createHeart(event);&#125;&#125;function createHeart(event)&#123;var d = document.createElement("div");d.className = "heart";hearts.push(&#123;el : d,x : event.clientX - 5,y : event.clientY - 5,scale : 1,alpha : 1,color : randomColor()&#125;);document.body.appendChild(d);&#125;function css(css)&#123;var style = document.createElement("style");style.type="text/css";try&#123;style.appendChild(document.createTextNode(css));&#125;catch(ex)&#123;style.styleSheet.cssText = css;&#125;document.getElementsByTagName('head')[0].appendChild(style);&#125;function randomColor()&#123;return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")";&#125;&#125;)(window,document); 总结这次修改的大部分还都是可以直接配置的，但还没有结束，这不是我的博客的最终样子。它还需要做最后的蜕变！ 下一篇文章应该就是大量的自定义样式了，敬请期待。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（二）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-02%2F</url>
    <content type="text"><![CDATA[有点无聊，有点焦虑。 今天下午刚搞完第一波Hexo的部署，晚上又闲的没事干，那就继续捣鼓这个博客吧。 这是第二篇有关Hexo的文章，没有看过第一篇的可以去瞅瞅： Hexo搭建Github Pages个人博客（一） 一、背景动画相信大家在浏览网站时肯定见过网页背景随鼠标移动而变化的特效，以前以为很高大上，原来就是引一个js库的事。 这个功能仅适用于next主题，其他主题没有实验过。 打开/themes/next/_config.yml，搜索Animation Settings，第一个默认是开启的，看着可配置项有fadeIn之类的，猜想应该就是首页加载时各个部件的渐隐效果，那就不去动它了。 下面第二个叫pace的，看注释应该是进度条动画，那我觉得聊胜于无，开启就是了。下面就以这个库为例，讲一下怎么开启这个动画效果。 首先当然是要把pace.enable设置为true，单单这样是不够的，next主题并没有包含这个插件。如果就这样去运行，页面不会发生任何变化，而且控制台还会报404错误。 因此下一步就是去下载这个插件，next主题很贴心地把插件的地址放在了注释里面： 下载之后将其解压到/themes/next/sources/lib下面，然后将文件夹重命名为pace。 其他插件的导入方式类似，文件夹的名称要和配置文件中的名称保持一致。 导入成功之后就可以运行查看效果了。默认的minimal是浏览器顶部的一个蓝色进度条动画（页面加载时显示，普通情况下一条黑边）。 为了方便大家对比，也是解决这个无聊的周末夜晚，我一个一个把这些效果实验一下，供大家参考： 1、进度条动画主题描述 进度条下面的就都是背景动画了，官方文档说不能同时开启两个，但我试了一下，可以呀，只是不太好看而已~ 我也把所有的背景动画的特效试了一下，大家可以看截图选择自己看着舒服的。 2、背景动画特效展示 注意：下载的插件要把目录中的.github目录删掉，否则提交到github之后会找不到插件的路径。 二、百度统计详见https://theme-next.iissnan.com/third-party-services.html#analytics-baidu 配置成功后可以将项目发布在github上，然后检查是否安装正确： 三、谷歌站点收录详见https://theme-next.iissnan.com/third-party-services.html#google-webmaster-tools 刚刚配置的时候忘了截图了，现在已经找不到那个页面了。 不过只要注意在输入网址之后展开第一种验证方式就可以找到我们要的代码了。 四、本地搜索功能用第三方搜索还要注册还要收费，我只需要一个简单的搜索哦~ 详见https://theme-next.iissnan.com/third-party-services.html#local-search 搭建完成的效果也还OK 五、显示文章基本信息就是这种效果： 打开_config.yml配置站点： 12345symbols_count_time: symbols: true # 文章字数 time: true # 阅读时长 total_symbols: true # 所有文章总字数 total_time: true # 所有文章阅读中时长 打开/themes/next/_config.yml配置主题： 123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 wpm: 275 这样我们只是配置好了，但是插件还没有安装，下面就安装插件（网上看的一篇文章说next主题自带该插件，我信以为真，结果死活不显示统计数量，也不报错，还专门去github上下载该插件，结果最后才发现是要用npm安装的。。。） 1$ yarn add hexo-symbols-count-time 然后重新运行就可以了，底部也会出现整个站点的统计字数。 六、滚动时显示文章进度在主题配置中搜索back2top，然后你懂的~ 123456back2top: enable: true # 在侧边栏显示该控件 sidebar: true # 显示阅读进度 scrollpercent: true 然后效果如下： 在点击这个控件后就会返回顶部。 虽然说放在侧边栏与潜意识里的返回顶部按钮不同，且用百分比来装饰，让人误以为它只是用来显示而不能点击的。但胜在能与周围融为一体呀，我不管，我就要这么设置！ 七、生成网站地图第三步已经生成了谷歌的站点地图，这里的设置主要是针对百度的。 安装sitemap插件： 12$ yarn add hexo-generator-sitemap$ yarn add hexo-generator-baidu-sitemap 然后将站点配置文件中的url改为自己的github地址即可。 重新运行，从地址栏输入/baidusitemap.xml查看有没有生成。 似乎百度不能抓取github.io下的内容，那搞它有什么用，不搞了不搞了。 八、附录1、进度条动画主题描述 theme 效果描述 big-counter 页面右上角显示加载百分比（数字） bounce 页面右上角显示一个跳动的小球，逐渐远去并消失 barber-shop 整个页面都被进度条占满。。。 center-atom 页面中间显示一个小花，花朵中间显示加载百分比 center-circle 页面中间显示有百分比的圆，有一个翻转消失的动画 center-radar 页面中间一个雷达旋转的动画 center-simple 顾名思义，特别简单，页面中间一个进度条 corner-indicator 右上角一个切角，里面是转圈的线条 fill-left 从左到右填充页面，与barber-shop的区别是不会遮挡页面元素。（十分不推荐选这个） flat-top 页面上方显示一个较宽的进度条 flash 页面上方显示较细的进度条，同时右上角有个加载状态的圆。（整体感觉不错，我可能会选它） loading-bar 同样是页面中间一个进度条。。 mac-osx 页面产生波浪，顶部有进度条。。（不是太好看呀，感觉侮辱了macOs呀） material 页面中间一个透明的圆，里面是百分比。（挺清爽的感觉，还可以） minimal 页面上方显示一个很细的进度条 这些主题尝试下来，有一个共同的特点，在页面超过一屏的情况下，顶部会有一个黑色的进度条区域（不管这里会不会显示进度条），所以建议选择带有顶部进度条的主题。 2、背景动画特效展示canvas_nest: 就是红框中的那些线条，可以跟随鼠标移动。 three.three_waves: three共包含三种特效，因此配置文件中有两个开关都要打开才行。 效果挺震撼的，在页面空白区域比较多的时候看着特别爽。 three.canvas_lines: three.canvas_sphere: 这个动画动的幅度比较小，一般只能在页面切换时才能看到，平时就被文章给盖住了。 canvas_ribbon： 这个不会动，只会在鼠标点击时切换背景。 总的来说，这些动画都挺好看的，但是我就觉得有一种哗众取宠的感觉。我的注意力应该放在文字本身，你旁边动来动去的背景是想干啥？ 所以最终我选择了奢华低调有内涵的three.canvas_sphere 最后，还是想说一下，本来想搞一个评论系统的，结果leanCloud刚实名认证不能创建应用，其他的要么被墙要么收费，真是难为死我了。 说不得还得来个Hexo系列文章三呢。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（一）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-01%2F</url>
    <content type="text"><![CDATA[以前也了解过Hexo，但因为各种操作都需要敲命令，我这么懒，就是不想敲命令~所以就没怎么玩过这个。这些天无意间了解到有个Hexo的客户端，觉得可以试试了。 搭建完成之后文章列表只有一篇HelloWorld，不能忍不能忍，于是诞生了这篇文章。。。。 一、开启Github Pages在Github中创建一个新的仓库，仓库名字为：[你的用户名].github.io,例如我的用户名为godbobo，那么填写的名称就是godbobo.github.io 其他什么都不用填，点击创建。然后打开该项目的Settings: 在Github Pages这个栏目下点击Choose Theme。（我这个是已经创建好的，界面和没有创建过的是不一样的） 然后会跳转到选择主题的界面，直接默认第一个就好，反正后面还要换成Hexo的，选择之后在新的页面点击commit提交更改，一个崭新的Github Pages就建立好了，并且可以直接通过刚才的项目名进行访问。 一个账号只能有一个Github Pages可以通过这种方式访问。 到这一步，Github Pages就算是配置好了，下面就要开始激动人心的Hexo配置了。 二、安装Hexo首先全局安装Hexo脚手架： 1$ npm install hexo-cli -g 不知道为什么，我用yarn安装之后命令行没有hexo这个命令，万般无奈之下，我还是用了npm来安装。。。 用脚手架初始化博客目录： 123$ hexo init godbobo.github.io$ cd godbobo.github.io$ yarn 这里为了保险起见我没把项目放到中文目录下，直接在D盘建的文件夹。 生成并运行Hexo： 12345$ hexo clean# g 即 generate$ hexo g# s 即 serve$ hexo s 打开浏览器localhost:4000，即可看到效果： 注意到地址栏了吗？我已经把它部署到Github Pages上了，要实现这样的效果，请看下回分解~ 哦不，是下一步。 三、部署到Github Pages本地安装git以及如何连接到github的过程就不在这里讲了，下面直接开始正文： 安装hexo-deployer-git： 1$ yarn add hexo-deployer-git 在生成的项目中可以看到有一个_config.yml的文件，它是hexo的用户配置文件： 我们需要在这里配置自己刚刚创建的Github Pages地址，在该文件中搜索deploy或直接到文件末尾，做出类似下图的修改： 然后命令行中输入： 12# d 即 deploy$ hexo d 如果是第一次执行这个命令会让你输入github的账号密码，输入之后就能够发布到Github Pages上了。 四、个性化配置1、主题配置主题可以在https://hexo.io/themes上面找到自己满意的，不过这里我还是推荐朴素又不失内涵的next主题，它还有四个子主题可供选择。 将主题下载下来后(直接download zip就行了，用git命令感觉好慢)，解压并将目录重命名为next，然后放到hexo项目的/themes/下。 然后打开项目（站点）配置文件_config.yml，搜索theme或直接到文件末尾，将默认主题改为next即可。 然后重新运行hexo s就可以看到主题已经改变。 2、设置语言运行后发现整个页面都是英文，我大字都不识几个让我看英文？这可不行。 打开站点配置文件_config.yml及主题配置文件/themes/next/_config.yml，搜索到language，并将其改为zh-CN即可。 放上我更换主题以及换了语言之后的页面样子： 3、设置next子主题咦，你的next主题怎么和我的不一样？我也要我也要~ 在刚刚hexo-next的github页面可以看到这个主题下一共有四个子主题可供选择： 经过一番挑选，我觉得Gemini可能更养眼一点，打开主题配置文件/themes/next/_config.yml，搜索scheme，将其改为Gemini并重新生成页面即可。 4、支持RSS如果自己能读到自己的Feed，那该有多好~ 安装hexo-generator-feed插件： 1$ yarn add hexo-generator-feed 完毕！ 没错，就是这么简单！ 点击RSS链接，就会跳转到atom.xml页面，这就表示RSS已经成功生成了。 五、使用hexo-client说了大半天，花里胡哨，我要怎么不费吹灰之力新建文章编辑文章？ 打开https://github.com/gaoyoubo/hexo-client这个仓库，在README的最下方有最新版的下载地址，然后下载并安装。 首次进入需要设置hexo项目的目录，设置即可。 目前整个项目还很简陋，编辑文章时虽说有上传图片的功能，但却不能通过剪切板上传，还是很鸡肋的。所以现在这篇文章我就是通过Typora来编写，PicGo来上传图片的。 整个软件用起来并不复杂，稍微摸索以下就会了，只是添加标签和分类的功能肉眼是找不到的，需要在编辑文章时找到Front-matter，在这个里面配置标签、分类信息： 其中title为tags表示标签，categories表示分类，如果要添加多个，需要使用yml文件的数组格式。 附录在查找问题的过程中了解到Hexo的文档，以后要深入折腾的话可以参考一下： Hexo文档 Hexo-Next主题配置文档 一般来说，每次更改内容后，最好要依次执行以下下面三个命令： 1234# 这条不执行应该也可以，我这里每次改东西后不执行它也不会有问题$ hexo clean$ hexo g$ hexo s 最后，看hexo官网中的描述，还有好多花样自己没有尝试过，比如评论功能，所以后续应该会有第二篇写hexo的文章。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
