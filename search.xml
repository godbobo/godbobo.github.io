<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年度总结]]></title>
    <url>%2F2019%2F12%2F27%2Fend-2019%2F</url>
    <content type="text"><![CDATA[人总是在不停得长大，一年又一年。当到了年尾，总会有很多感慨想要抒发，有很多事情想要总结。但万万没想到，还有很多事情要被迫总结。 那么，多情的我只好写两份总结啦。下面是我的个人自愿版总结： 概述总的来说，今年相较于往年，自己的生活已经可以用丰富多彩来形容了。可能也是因为毕业季的原因吧，又是毕业论文又是找工作的，反正就是可以拿出来说的事情有很多很多。 今年的我从1月份就开始忙碌起来了，放了寒假之后就立马去找工作了。也算是比较幸运的吧，不爱背题面试准备不充分的我竟然在一星期的漫漫求职路中通过了。在公司过完年会之后回家过了个年，然后就开始边工作边补自己的毕业设计了，在做这个设计的时候才知道要搞一个完整的系统有多难，没办法，时间也紧，就草草做了一个还看得过去的毕设出来。到了四五月份，学校就催着回去搞论文了，我一听到截止日期，就天真地回去了，结果大家都不回来，搞得我多在学校待了几个星期。不过却也算把论文搞得像模像样了，这一点还是要谢谢张翔老师的，虽然最后没把我的论文作为优秀毕业论文，不过我也没有特别看重这个。毕竟自己越长大，对生活的要求就越低了，能过就好了嘛，很满足了。然后又回到杭州开始了苦逼了码农生活，期间将自己租的房子换得离公司近了一点，少走了几步路，不过也激发了自己的惰性，自从搬家之后就很少自己做饭了。然后从十月份到现在，就是还算奢靡的生活了，把自己所能用到的电子产品都买了个遍，只想说一句，能挣钱的感觉真好。 工作总结在1月份那几天的面试过程中，我也算是碰了很多次壁，有问我问题我答不上来的，有劝我去培训的，还有劝我转行的。 找工作对于一些人来讲可能是人生的一个小小的分叉路口，但对于我来说并不是这样，因为我没有第二条路，我只想做程序员，如果现在的我不能，那我宁愿去被培训机构培训之后再来做。 不过还好，在不是特别好的求职时间段中，我现在的这家公司接纳了我，算是给我了一个在杭州的容身之地和待在杭州的理由。 说到为什么会选择来杭州，其实也没那么多为什么，这对于我来说就是一个玄学的问题。在高考填报志愿的时候，我就因为我暗恋的女生名字里有个“楠”字而把所有志愿报到了南方，虽然她还在省内。。。 而选择来杭州，一是自己的工作性质，在家里那种小城市肯定是不好找工作的，二是年轻人总要多出来闯荡闯荡，三可能是我想往更南方走一点，四是深圳那种地方，大晴天突然给你下一顿雨，来也匆匆去也匆匆的，让我这种十分不爱带伞的人很不爽，很怕，那里还会随时查你身份证！我不爱带钱包，自然也不爱带身份证！如果不是我对于手机那刻骨铭心的爱，说不定我连手机也不爱带呢。 这样综合一考虑，也就上有天堂下有苏杭的电商之都，杭州似乎是我最理想的城市了。 刚开始工作的时候，看公司的代码，一个后台200多M的代码，也算是让我长见识了。不过后面看里面的代码，其实重复的东西也是有很多的，而且用了一次就不用的东西也有很多，里面的代码质量和自己的比起来，说不定真是自己更胜一筹呢。不过慢慢的，也发现了里面有很多我以前没有了解过的很实用的东西，还是很值得我去了解一下的。 在写后台的时候，最让我头疼的就是里面的各种业务逻辑了，光整理逻辑就要花大半天，有的时候光凭自己瞎找还搞不定，真的是一有这种任务就会有点后怕。 之后就还算好点了，我基本上就专职搞公司的前端了，用自己现学现卖的uni-app框架把公司的微信端网页给重构了，还用Vuejs写了两个后台管理系统的项目，也算是前端修炼小成了。 不过正当我准备在前端大展身手的时候，领导需要我去做后端了。那我自然是乐意的，毕竟后端正在用最近很火热的微服务架构去重构，这么热门的技术我不去了解一下怎么能行？虽然这样又要涉及到复杂且繁琐的业务逻辑的梳理了，但一切为了技术，都是值得的！希望明年可以有更好的发展吧 生活总结刚来杭州找到工作之后，第一件事就是要确定自己的住处。当时也真是“果断”，看了一个还算便宜的房子，就立刻租下来了。直到拿快递的时候才知道我在的地方不是滨江区而是萧山区，自那时起我就下定决心以后不租这种“公寓“式的房子了，不仅要自己以贷款的名义先让他们资金回笼，业务员还为了达成交易不择手段，欺骗我幼小的心灵，哼！ 不过那个房子除了离公司远点之外，房间面积小点之外，似乎也还是挺不错的。至少在刚开始的几个月，没有室友的时候，天天都能独占一整个房子，想躺客厅哪里就躺哪里，想怎么做饭就怎么做饭，想怎么哼歌就怎么哼歌。 后面来室友了，一个个都是情侣，一点也不给我想象中的爱情的发展空间，当然就算有想象空间了对我而言可能也真的就是想想而已。 刚开始工作的时候，由于是实习生，工资低的可怜，一个月才2000。没办法，只好能省则省了，也就是那个时候开始尝试自己去做饭，炒菜，也算是有了一点点自己的心得了。记得最深的一次就是我在炒菜的时候锅里着火了，刚开始我还很开心，觉得自己要变身大厨了，连电视里厨师做饭的效果都搞出来了。结果那火一直不灭，越着越旺，我就开始慌了，把🔥调小也没用，急的我直接把锅从灶台上拿下来放到地上降温，真的是惊心动魄。 毕业之后工资总算高了点，就给自己找了个离公司还算近的地方，每天上下班骑车的话十五分钟左右就可以到了。 可是，为什么，这个月我又迟到了五次😭 在这里就是有一点不好，做饭太不方便了，这让比较懒的我更多了一个借口不去做饭了。说到懒，我是真的无解了，大概是从3月份得知办市民卡之后可以免费骑公共自行车，就想着要办一下。结果到年底了，我还没有去办，只能寄希望于明年我有这个决心可以尽早办一下吧。 物质方面，由于近段时间转正后工资的提升以及杭州市政府的一次补贴，让我有了更多买东西的想法。前前后后的，把MacBook Air、AirPods、机械键盘、妙控鼠标和显示器都算是补充完毕了，自此，短期内是没有什么特别想要的电子产品了。 今年也是自己用ihpone的第一年，说真的，除了新iPhone上市的时候有些心动之外，我真的没有一点换手机的想法，就算是5G也对我没什么吸引力了。在这一点上，我只能说一句苹果真香！ 情感总结如上所示 一片空白 兴趣总结很幸运的是，我的兴趣就是我的工作，所以对于我工作上的任何成果，我都是会非常开心的。 第一点就是完成了自己的毕业设计《校园博客系统的设计与实现》，这算是自己独立完成的第二个项目了（第一个应该算是自己胎死腹中的安卓音乐播放器了），在做这个系统时，自己用到了很多最新的技术，比如前后端分离，比如Vue和SpringBoot，都是我在边学边做的过程中完成的。自然，代码质量肯定不会太高，但也是有一定的水准的。下面把地址贴上： https://github.com/godbobo/school-blog-vue22次提交 https://github.com/godbobo/school-blog-springboot22次提交 然后就是自己独立一人将公司原有的微信前端项目用uni-app改造后并上线了，虽然也出过不少bug，但大部分最后都解决了。现在基本上就剩两个小问题我无从下手了，一是微信的浏览器缓存实在顽固，每次更新总会有用户手机里有缓存清不掉，二是框架自动提示的网络不给力问题，报bug给官方官方也不重视起来，让我有想骂人的冲动。由于是公司的代码，就只放上一张打码后的首页截图留做纪念吧。 还有就是从零开始用Vuejs写的一个后台管理系统，那时的自己了解到的东西并不多，所以代码质量什么的真的不是特别好。再后面根据现有的后台管理系统改造成Vue项目，虽然还没用起来，但我基本上是很用心地把能完善的地方都完善了一下，总会有上线的一天的。 在写uni-app项目的时候，还抽空写了两个组件发布到了插件市场，目前虽然也不火热，但用的人也没有特别差的评论，其实也就挺满足了。 中间还因为买了Mac，去买了本写IOS软件的书，买了写IOS软件的视频教程。结果学了之后感觉差不多都掌握了，但真正去做的时候还是很难下手，这点感觉有点不爽。 最近又沉迷在了electron开发当中，希望能开发一款属于自己的Markdown编辑器，来代替自己现在在用的这个。 不过就在今天晚上谈定了一个私活，做好后等于自己一个月工资，看来接下来的这个年怕是过不好喽～不过还是感谢显威给了我一个赚钱的机会😘 浮云流水心情因为能多赚钱而觉得有些浮躁，就不想那么多了。下面用照片回顾一下今年的历程。 这是充满希望的时刻，每张照片里都有光亮在前方。 2018-12-30 这是孤独的时刻，一个人在冰天雪地里，希望能留下与景德镇最后的回忆。 2018-12-31夜 和室友跨年 这是彷徨的时刻，不知前路在何方。 2019-01-01 现实且充满希望的新年祝福 毕业啦 2019-01-07 这个夜晚，见证了郭园的悲欢离合的那群人 2019-01-13 临别时的矫情 2019-01-13 端阳兄请客！ 2019-01-16 没有面试？西湖走起！ 2019-01-18 确定工作后的展望 01-21 上班是件充满朝气的事情（当然，现在又开始赖床了） 02-24 兄台，你这个地方有点问题，来，我指给你看！ 03-03 不会做饭怎么办？当然是请人来做！ 03-17 啥玩意儿？有比赛看？ 03-30 草长莺飞的季节 03-30 西溪且留下 04-20 再续前缘 06-07 万千繁华隐于世 06-19 上班路上 07-03 咋又见面了，不是说好不见的吗 07-05 真香，见的好！ 09-08 惬意 09-13 身在潮边仍要看电视观潮的无奈 09-21 公司团建 10-05 天上地下我最穷！ 10-05 猜猜哪个是出自心灵手巧的我？ 10-19 周末在庐山 11-18 可能是买回来树莓派后的最高光时刻 12-19 边听歌边敲代码的休闲时光 攒了这么多图片，一口气发出来的感觉真好。 结在这一年里，作为自己人生的一个转折点，自我感觉转的方向是对的。至于后续，走一步看一步吧。 一个人生活的一年时光里，最多的感觉莫过于孤独，最渴望的也莫过于爱情。但越渴望，越觉得害怕，每每想到这里，都觉得自己以后还是去相亲靠谱。可相亲又是最看重现实情况的，这样一想，一个人倒也不过，每个月留不住钱却也活得自在。 明年加油吧，还是那个不切实际的愿望。 希望它能实现。 希望它不能实现。]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在自己的网站中启用HTTPS服务]]></title>
    <url>%2F2019%2F12%2F18%2Fssl%2F</url>
    <content type="text"><![CDATA[看着身边的网站一个个在地址栏都有了小锁的标志，自己也是心痒痒呀。正好今天手头的事情不多，就来搞了一下这个东西。 一、SSL证书平台选择首先，提供SSL证书的平台有很多，各种云计算平台也都有提供的。不过他们提供的免费证书大部分都是有时间限制的，三个月到一年不等，到期就要自己手动续期。 本着一劳永逸的原则，我开始了寻找SSL证书平台之旅。结果并没有找到自己想要的结果，不过中途却发现了有些平台用的就是Let’s Encrypt这个平台的证书，就是做了一个中间商，只不过不赚差价而已。而我生平，最讨厌中间商。 于是我直接找到了“厂商”，点击Get Started，就开始了探索CentOs下Nginx服务器安装SSL证书的旅程。 剧透一下结果：证书同样需要续期，不过可以安装工具自动续期，相当于永久的证书了。 在快速入门章节，可以看到有两种方式可以获取到SSL证书。而我的情况，适用于第一种，拥有命令行访问权限。 摘自https://letsencrypt.org/zh-cn/getting-started/ 我们建议大多数具有命令行访问权限的人使用 Certbot ACME 客户端。它可以在不下线您的服务器的前提下自动执行证书颁发和安装。对于不需要自动配置的用户，Certbot 还提供专家模式。它易于使用，适用于许多操作系统，并且具有出色的（注：英文）文档。访问 Certbot 官网 以获取针对于操作系统和 Web 服务器的订制文档。 所以接下来，就是如何使用certbot的问题了。 二、配置环境并安装CertBot在Let’s Encrypt的快速入门页面中，可以找到CertBot官网的链接。 进入CertBot官网后，首先它让我们检查自己的网站是否已经有了HTTPS访问的功能。很显然，我的并没有，于是就需要安装CertBot了。 点击右边的Get Certbot instructions来查看Certbot的使用说明。 在新的页面里，会让你选择自己的服务运行环境，我这里就是Nginx运行在CentOS7上面，所以按下图这样选择。 然后向下滚动页面就可以看到适用于自己系统的安装方式了。 第一步是通过SSH连接到服务器，第二部具体是在干嘛的不太清楚，就按它的要求开启这个东西就行了。开启方法如下： 1yum install epel-release 第三步是开启可选模块，我当时啥都没想直接就开启了，现在想想似乎并不需要开启这个，因为那啥Oracle Linux应该和我无关吧。不过保险起见还是把命令列出来吧，下次再安装的时候万一就用到了呢。 123yum -y install yum-utilsyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional 接下来就是安装本篇文章的主角Certbot了。 1sudo yum install certbot python2-certbot-nginx 三、修改nginx配置文件并启用SSL证书接下来，就到了第五步了。这时，它又让我选择安装方式，那看了说明自然是第一种简单呀，一键自动化配置，爽！ 1sudo certbot --nginx 爽不过一秒，命令行就报错了。 这里还要说一下，如果是第一次执行这个命令，会让你输入自己的邮箱，输入一下即可。 看上面说的，再去搜索了一下相关问题，大概知道是自己在nginx配置文件中用了中文注释的原因。删掉后再次运行，又卡在了服务器验证这一步，看来安装SSL服务并没有想象中那么简单啊。 然后在一番乱搜之后，在这两篇文章的帮助下我完成了SSL服务的搭建。 How To Secure Nginx with Let’s Encrypt on CentOS 7Secure Nginx with Let’s Encrypt on CentOS 7 在第一篇文章里，我用一下命令更新了一下自己的防火墙配置： 12345678# 允许http和https和重定向访问sudo firewall-cmd --add-service=httpsudo firewall-cmd --add-service=httpssudo firewall-cmd --runtime-to-permanent# 允许外网访问80端口和443端口sudo iptables -I INPUT -p tcp -m tcp --dport 80 -j ACCEPTsudo iptables -I INPUT -p tcp -m tcp --dport 443 -j ACCEPT 这样做了之后，还是没有效果（以前曾经把80端口放开过），然后又参考第二篇文章，终于成功了，具体步骤如下： 1、生成强Dh (Diffie-Hellman)群（并不懂在说啥，敲代码就是了）1sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 这个步骤需要花费一段时间，屏幕中会有大片英文逗号出现。 2、创建存放证书的目录 我猜是这么回事。进行HTTPS访问时，总会有一个额外的操作用来获取证书内容，那证书从哪里来呢？当然要找个地方存起来才能让浏览器获取。 12345sudo mkdir -p /var/lib/letsencrypt/.well-knownsudo chgrp nginx /var/lib/letsencryptsudo chmod g+s /var/lib/letsencryptsudo mkdir /etc/nginx/snippets 目录创建好之后，将下面两个文件创建到/etc/nginx/snippets目录下面： /etc/nginx/snippets/letsencrypt.conf 123456location ^~ /.well-known/acme-challenge/ &#123; allow all; root /var/lib/letsencrypt/; default_type &quot;text/plain&quot;; try_files $uri =404;&#125; /etc/nginx/snippets/ssl.conf 123456789101112131415161718ssl_dhparam /etc/ssl/certs/dhparam.pem;ssl_session_timeout 1d;ssl_session_cache shared:SSL:50m;ssl_session_tickets off;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers &apos;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&apos;;ssl_prefer_server_ciphers on;ssl_stapling on;ssl_stapling_verify on;resolver 8.8.8.8 8.8.4.4 valid=300s;resolver_timeout 30s;add_header Strict-Transport-Security &quot;max-age=15768000; includeSubdomains; preload&quot;;add_header X-Frame-Options SAMEORIGIN;add_header X-Content-Type-Options nosniff; 看到上面的文件内容基本可以知道，这是Nginx配置文件的格式。把这个配置文件单独拿出来存放应该是为了在Nginx主配置文件中复用上面的配置内容（每个不同的域名均需要配置SSL证书）。 3、修改Nginx配置文件这时，我们需要在Nginx配置文件中的server区域内加入下面这句话： 1include snippets/letsencrypt.conf; 这时，这个配置文件就大概应该是这个样子的： 123456server &#123; listen 80; server_name example.com www.example.com; include snippets/letsencrypt.conf;&#125; 然后重启Nginx服务器： 1systemctl reload nginx 然后教程中的下一步是以certbot certonly开头的一段命令，用于获取对应域名的证书。而我运行这个命令死活不成功，会报No valid IP addresses found for aqzscn.com的错误。 万念俱灰之下，我又回到Certbot的说明文档，执行了一下sudo certbot --nginx，结果一路畅通无阻，中间还提示我是否要将HTTP请求重定向为HTTPS请求，那当然OK呀。 下面是我生成证书成功后提示的内容： 12345678910111213IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/www.aqzscn.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/www.aqzscn.com/privkey.pem Your cert will expire on 2020-03-17. To obtain a new or tweaked version of this certificate in the future, simply run certbot again with the &quot;certonly&quot; option. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 证书生成成功之后，还需要做的就是自动更新证书，在命令行中敲以下命令即可： 1echo "0 0,12 * * * root python -c 'import random; import time; time.sleep(random.random() * 3600)' &amp;&amp; certbot renew" | sudo tee -a /etc/crontab &gt; /dev/null 四、测试结果这个时候，就到了检验结果的时候了。 在浏览器地址栏输入自己的域名后，预期的网页终于出现了。不过奇怪的一点是，如果我不加HTTPS，它并不会给我重定向到HTTPS的请求。 因为我这个域名下面还有几个子域名，于是我将其也加入了HTTPS访问。但这次我在地址栏输入care.aqzscn.com时，它又确实给我重定向到HTTPS请求了。很奇怪很奇怪，应该是有哪里没有搞好把。 此时又出现了一个问题就是我的后台服务没有开启HTTPS服务，好难啊。。 总结总的来说，这次是实现了在网站中添加SSL证书的功能，其中还是有一些不足需要完善，不过还是留到下次再说吧，到时候研究一下能不能把相同的证书用在没有域名的服务器上，或者说就用自己生成的证书来提供HTTPS服务，反正API请求的地址用户也看不到了。]]></content>
      <categories>
        <category>用就对了</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目手写一个局部打印的组件]]></title>
    <url>%2F2019%2F12%2F02%2Fweb-print%2F</url>
    <content type="text"><![CDATA[后台管理系统当中，报表的打印和导出是非常常用的功能，这次我就记录一下如何手写一个局部打印功能的组件。 最终实现效果： 上图的数据打了马赛克，不过还是基本能看出来实现了局部打印功能，并且表格的样式都能正常显示。为了实现这个局部打印功能，我在中间还是趟了不少坑的。 一、实现局部打印的方式浏览器的window对象有一个print()方法可以用来打印，但这种方式只能打印整个网页，不能对具体的某个元素进行打印，并且dom元素对象中也没有相关的打印方法，这就使得局部打印必须采取一些技巧才能实现。 第一种方式是新建窗口（标签页），专门放打印内容，然后调用window.print()方法进行打印。但这种方式就要每一个打印内容都需要新建页面（标签页必须得有网址，不能用js凭空创建），不能进行有效的复用。 第二种方式是用iframe标签，在里面放置打印内容，然后调用iframe.contentWindow.print()方法进行打印。这种方式需要处理很多细节上的东西，但处理之后其他地方就可以进行简单的调用了。 综合考虑，最终我选择使用第二种方式，并且使用组件来做而非常规的js文件（可以方便地使用vue的模板渲染表格）。 另外就是使用jquery插件printArea，但是作为一个高端的vue项目，怎么能jQuery这种东西呢？遂弃之。 还有就是printjs、vuePlugs_printjs等纯js插件，printjs可以打印，但样式不能设置成我满意的样式；vuePlugs_printjs样式和原内容一样，但不能将超出内容自动分页，遂弃之。 二、实现局部打印这里参考了vuePlugs_printjs的源码，在此表示感谢。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;!-- 打印占位 --&gt; &lt;iframe id="printf" src width="0" height="0" frameborder="0"&gt;&lt;/iframe&gt; &lt;!-- 打印内容,我这里是为了打印表格，你也可以替换为自己需要打印的内容 --&gt; &lt;table ref="printTable" id="printTable" class="spl-table"&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'simple-table', methods: &#123; /** * 打印表格内容 */ printTable () &#123; // 1.获取要打印的内容的一份复制，否则待会儿添加节点时会将原有内容删除 const content = document.getElementById('printTable').cloneNode(true) // 2.获取放置打印内容的iframe const ifm = document.getElementById('printf') // 3.添加打印内容样式 let str = '' const styles = document.querySelectorAll('style,link') for (let i = 0; i &lt; styles.length; i++) &#123; str += styles[i].outerHTML &#125; ifm.contentDocument.write(str) // 4.添加打印内容并打印 // 使iframe中存在body元素，便于使用dom元素的方法 ifm.contentDocument.write('&lt;div&gt;&lt;/div&gt;') ifm.contentDocument.close() ifm.contentDocument.body.appendChild(content) ifm.contentWindow.print() &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;@import './simple-table.css';&lt;/style&gt; 上面代码中的注释已经写的很全面了，重点就是要将当前页面中的样式定义导入到&lt;ifrme&gt;元素中。并且在导入dom元素时没有将其转为字符串写入，而是直接采用appendChild()方法插入dom元素，这是因为转为字符串插入过程中一些dom元素会丢失导致表格显示异常。不过用了这种dom节点插入的方式之后，原有的节点就会被移动到这里，那么用户重复打印时这个组件的打印功能就失效了，这显然不是我们想要看到的结果。因此在前面创建了一个打印内容的复制，保证在插入节点后原节点依旧存在。 三、超出内容分页、隐藏打印内容在上面的代码实现了局部打印功能之后，当打印内容超出一页时，我发现打印预览却依然只有一页，而在正常页面中直接右键打印却可以自动分页，那到底是哪里出了问题呢? 在参考了这篇文章之后，我明白了问题所在：我们的后台管理系统基本上body、html都是固定高度的，此时window的打印功能就只能确定一页的高度，因此我们需要将body和html的高度自适应子元素的高度，即： 123html, body &#123; height: inherit;&#125; 但是先别急，这样一设置我们的后台管理页面不就乱了套了嘛，此时就要用到CSS的媒体查询了： 12345678910/* 打印时显示 */@media print &#123; .spl-table &#123; display: table; &#125; html, body &#123; height: inherit; &#125;&#125; 上面代码中同样将我们要打印的内容显示出来了，因此在普通的样式中我们就要将打印内容隐藏起来。这样就可以实现一个较为完美的局部打印功能了。 附录：简单的表格打印组件下面是我实现的一个表格打印组件（环境：Vue+iview表格）。iview表格用于在查询界面显示报表，这个表格打印组件用于显示标准的表格打印内容。所以这个组件的各种参数都是以iview中的Table组件的参数来定义的，为的就是不用对同一个数据源做两次改变。 组件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;template&gt; &lt;div&gt; &lt;!-- 打印占位 --&gt; &lt;iframe id="printf" src width="0" height="0" frameborder="0"&gt;&lt;/iframe&gt; &lt;!-- 打印内容 --&gt; &lt;table ref="printTable" id="printTable" class="spl-table"&gt; &lt;caption&gt; &lt;!-- 自定义header插槽，用于放置自定义标题内容，详见https://cn.vuejs.org/v2/guide/components-slots.html，注意：建议不要与下方title一起使用 --&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;div class="spl-fz16"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; &lt;div class="spl-fz12"&gt;&#123;&#123;subTitle&#125;&#125;&lt;/div&gt; &lt;/caption&gt; &lt;thead&gt; &lt;!-- 遍历标题 --&gt; &lt;tr v-for="n in headLoopData.trNum" :key="n"&gt; &lt;th v-for="(th, thIndex) in headLoopData.deepArray[n - 1]" :key="thIndex" :rowspan="hasChildren(th) ? 1 : (headLoopData.trNum - n + 1)" :colspan="hasChildren(th) ? th.children.length : 1" &gt;&#123;&#123;th.title&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 遍历数据 --&gt; &lt;tr v-for="(item, trIndex) in data" :key="trIndex"&gt; &lt;template v-for="(pptDe, tdIndex) in headLoopData.columnDefines"&gt; &lt;td v-if="rowAndColSpan(trIndex, tdIndex).indexOf(0) &lt; 0" :key="tdIndex" :rowspan="rowAndColSpan(trIndex, tdIndex)[0]" :colspan="rowAndColSpan(trIndex, tdIndex)[1]" :class="tdClass(rowAndColSpan(trIndex, tdIndex))" &gt;&#123;&#123;tdContent(item, pptDe, trIndex)&#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'simple-table', props: &#123; // 列定义 columns: &#123; type: Array, default: function () &#123; return [] &#125; &#125;, // 表格数据 data: &#123; type: Array, default: function () &#123; return [] &#125; &#125;, // 合并单元格策略(要隐藏的单元格需设置span为0，否则会导致表格显示错位) spanMethod: &#123; type: Function, default: function () &#123; return [1, 1] &#125; &#125;, // 标题 title: &#123; type: String, default: '' &#125;, // 二级标题 subTitle: &#123; type: String, default: '' &#125; &#125;, computed: &#123; // 显示标题行所需的变量 headLoopData () &#123; // 行数 let trNum = 0 // 每层标题的数据 const deepArray = [] // 每列的定义 const columnDefines = [] // 计算列定义深度 function countDeep (obj, num) &#123; if (num &gt; 0) &#123; deepArray[num - 1].push(obj) &#125; if (obj.children &amp;&amp; obj.children.length) &#123; num++ if (num &gt; trNum) &#123; trNum = num deepArray.push([]) &#125; obj.children.forEach(item =&gt; &#123; countDeep(item, num) &#125;) &#125; else &#123; columnDefines.push(obj) &#125; &#125; if (this.columns.length) &#123; trNum = 1 deepArray.push([]) &#125; this.columns.forEach(item =&gt; &#123; countDeep(item, 1) &#125;) return &#123; trNum, deepArray, columnDefines &#125; &#125; &#125;, methods: &#123; /** * 是否有子节点 * @param th - 列定义数组中的对象 */ hasChildren (th) &#123; return th.children &amp;&amp; th.children.length &#125;, /** * 单元格合并策略 * @param rowIndex - 行索引 * @param columnIndex - 列索引 */ rowAndColSpan (rowIndex, columnIndex) &#123; let de = [1, 1] if (this.spanMethod &amp;&amp; this.spanMethod instanceof Function) &#123; de = this.spanMethod(&#123; rowIndex, columnIndex &#125;) &#125; return de &#125;, /** * 单元格显示内容 * @param row - 行数据 * @param colDe - 列定义 * @param trIndex - 行索引 */ tdContent (row, colDe, trIndex) &#123; if (colDe.type === 'index') &#123; return trIndex + 1 &#125; else &#123; return colDe.key ? row[colDe.key] : '' &#125; &#125;, /** * 单元格样式 * @param spanDef - 单元格合并结果，例:[1,1] */ tdClass (spanDef) &#123; if (spanDef[0] &gt; 1 || spanDef[1] &gt; 1) &#123; // 合并单元格后设置单元格内容居中显示 return 'cell-center' &#125; else &#123; return '' &#125; &#125;, /** * 打印表格内容 */ printTable () &#123; // 1.获取要打印的内容的一份复制，否则待会儿添加节点时会将原有内容删除 const content = document.getElementById('printTable').cloneNode(true) // 2.获取放置打印内容的iframe const ifm = document.getElementById('printf') // 3.添加打印内容样式 let str = '' const styles = document.querySelectorAll('style,link') for (let i = 0; i &lt; styles.length; i++) &#123; str += styles[i].outerHTML &#125; ifm.contentDocument.write(str) // 4.添加打印内容并打印 // 使iframe中有body元素 ifm.contentDocument.write('&lt;div&gt;&lt;/div&gt;') ifm.contentDocument.close() ifm.contentDocument.body.appendChild(content) ifm.contentWindow.print() &#125;, exportTable () &#123; // excel.export_table_to_excel('tryprint', '测试表格.xlsx') &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;@import './simple-table.css';&lt;/style&gt; 样式文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 默认隐藏 */.spl-table &#123; width: 100%; border-collapse: collapse; display: none;&#125;/* 打印时显示 */@media print &#123; .spl-table &#123; display: table; &#125; html, body &#123; height: inherit; &#125;&#125;.spl-table caption &#123; font-weight: bold; line-height: 26px;&#125;.spl-table thead tr &#123; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(211, 202, 221);&#125;.spl-table thead th &#123; padding: 5px 10px; font-size: 13px; font-family: Verdana; color: rgb(95, 74, 121); border-style: solid; border-width: 1px;&#125;.spl-table tbody td &#123; padding: 5px 10px; font-size: 12px; font-family: Verdana; color: rgb(95, 74, 121); border-style: solid; border-width: 1px;&#125;.spl-fz16 &#123; font-size: 16px;&#125;.spl-fz12 &#123; font-size: 14px;&#125;.cell-center &#123; text-align: center; vertical-align: center;&#125; 使用示例 12&lt;!-- 打印组件 --&gt;&lt;simple-table ref="spTable" :columns="tableColumns" :data="tableList" :span-method="controlTableSpan" title="统计报表" sub-title="2019-12-15 ~ 2019-12-30 统计报表"/&gt; 12// 执行打印方法this.$refs['spTable'].printTable() 另外还有一个功能是将表格内容强制分页，同样是利用CSS来做的，思路就是将要分页的表格分成多个table，然后在table之间加上css分页样式：page-break-after: always;即可。不过怎么在这个组件中实现我暂时还没有思路，先在此记录一下。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>网页打印</tag>
        <tag>网页开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派入门之4位数码管]]></title>
    <url>%2F2019%2F11%2F19%2Fraspberry-digital-tube%2F</url>
    <content type="text"><![CDATA[数码管长这个样子： 数码管分为静态数码管和动态数码管，如果是静态数码管的话针脚数量不敢想象，我这个是动态的数码管，所以只有12个针脚。 可能大家还不是很懂，可是解释啥的感觉自己也不太会，就放上一个链接供大家参考： https://www.cnblogs.com/badnewfish/p/5908423.html 然后放上驱动的代码（显示当前时间）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#!/usr/bin/env python# encoding: utf-8import RPi.GPIOimport time# abcdefg 从上边开始顺时针编号， dp 表示小数点 dotpoint# 定义单个数码管各段led对应的GPIO口LED_A = 26LED_B = 19LED_C = 13LED_D = 6LED_E = 5LED_F = 11LED_G = 9LED_DP = 10# 定义1到4号数码管阳极对应的GPIO口DIGIT1 = 12DIGIT2 = 16DIGIT3 = 20DIGIT4 = 21# 定义按钮输入的GPIO口# btn = 27RPi.GPIO.setmode(RPi.GPIO.BCM)RPi.GPIO.setup(LED_A, RPi.GPIO.OUT)RPi.GPIO.setup(LED_B, RPi.GPIO.OUT)RPi.GPIO.setup(LED_C, RPi.GPIO.OUT)RPi.GPIO.setup(LED_D, RPi.GPIO.OUT)RPi.GPIO.setup(LED_E, RPi.GPIO.OUT)RPi.GPIO.setup(LED_F, RPi.GPIO.OUT)RPi.GPIO.setup(LED_G, RPi.GPIO.OUT)RPi.GPIO.setup(LED_DP, RPi.GPIO.OUT)RPi.GPIO.setup(DIGIT1, RPi.GPIO.OUT)RPi.GPIO.setup(DIGIT2, RPi.GPIO.OUT)RPi.GPIO.setup(DIGIT3, RPi.GPIO.OUT)RPi.GPIO.setup(DIGIT4, RPi.GPIO.OUT)RPi.GPIO.output(DIGIT1, True)RPi.GPIO.output(DIGIT2, True)RPi.GPIO.output(DIGIT3, True)RPi.GPIO.output(DIGIT4, True)# RPi.GPIO.setup(btn, RPi.GPIO.IN, pull_up_down=RPi.GPIO.PUD_UP)# 指定no(1-4)号数码管显示数字num(0-9)，第三个参数是显示不显示小数点（true/false）def showDigit(no, num, showDotPoint): # 先将正极拉低，关掉显示 RPi.GPIO.output(DIGIT1, False) RPi.GPIO.output(DIGIT2, False) RPi.GPIO.output(DIGIT3, False) RPi.GPIO.output(DIGIT4, False) if (num == 0) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, False) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, True) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 1) : RPi.GPIO.output(LED_A, True) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, True) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, True) RPi.GPIO.output(LED_G, True) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 2) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, True) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, False) RPi.GPIO.output(LED_F, True) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 3) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, True) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 4) : RPi.GPIO.output(LED_A, True) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, True) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 5) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, True) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 6) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, True) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, False) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 7) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, True) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, True) RPi.GPIO.output(LED_G, True) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 8) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, False) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) elif (num == 9) : RPi.GPIO.output(LED_A, False) RPi.GPIO.output(LED_B, False) RPi.GPIO.output(LED_C, False) RPi.GPIO.output(LED_D, False) RPi.GPIO.output(LED_E, True) RPi.GPIO.output(LED_F, False) RPi.GPIO.output(LED_G, False) RPi.GPIO.output(LED_DP, not showDotPoint) if (no == 1) : RPi.GPIO.output(DIGIT1, True) elif (no == 2) : RPi.GPIO.output(DIGIT2, True) elif (no == 3) : RPi.GPIO.output(DIGIT3, True) elif (no == 4) : RPi.GPIO.output(DIGIT4, True)try: t=0.005 i = 0 while True: # 按钮按下时显示日期，否则显示时间 # 为了区别左右的数字，让第二个数码管的小数点显示出来 #（本来应该是一个冒号，我们这个数码管没有，就用小数点代替了 currentTime = time.localtime(time.time()) currentH = int(time.strftime("%H", currentTime)) currentM = int(time.strftime("%M", currentTime)) time.sleep(t) showDigit(1, int(currentH / 10), False) time.sleep(t) showDigit(2, int(currentH % 10), True) time.sleep(t) showDigit(3, int(currentM / 10), False) time.sleep(t) showDigit(4, int(currentM % 10), False)except KeyboardInterrupt: pass# 最后清理GPIO口（不做也可以，建议每次程序结束时清理一下，好习惯）RPi.GPIO.cleanup() 这里着重要说的就是接线，接线的话上面代码里定义的GPIO编号不要改，接线时刚好能连在一块。 首先拿出12根线，连到数码管上，连的时候注意四根控制四个数字发光的线的颜色最好类似，方便我们识别，我这里用的是白色的线。 连上之后就要参照代码中定义的A对应哪条线，这条线又对应哪个GPIO引脚这样的思路去接线，接完之后就可以运行程序了。 然后就是见证奇迹的时刻：]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>数码管</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派入门之有源蜂鸣器]]></title>
    <url>%2F2019%2F11%2F19%2Fraspberry-active-buzzer%2F</url>
    <content type="text"><![CDATA[在资金本来就不怎么充裕的双十一，我忍痛买下了价值近700的树莓派4B+，从此开始了我的物联网之旅～～（当然，才刚开始～） 在漫长的等待之后，它终于到了我手上。在将它开机并和我的Mac连接上之后，我并不知道该如何去用剩下的一堆传感器，遂打算看一本入门教程，然后发现教程里的入门实验是用LED灯的，还要用电阻之类的。我扒拉了一下这一盒东西，有点想哭，竟然什么都没有。无良商家啊，我都买最贵的套餐了，我只想入个门啊，怎么连这点都洗都不给配呢？ 不甘心的我又不想这么快就去买新的配件，就随意在网上看，就发现了有源蜂鸣器的触发方式和LED灯一样，十分简单，就只要发一个信号就可以了。而我刚好有这个东东，那么就开始进入正文吧。 一、简单了解树莓派的接口树莓派与这些传感器及其他硬件的通信基本上都是通过左上角的一排针来完成的，这些针基本上分为电源针、GPIO接口针和接地针，就是下图中标着0的那一块。 我买的这个树莓派一共有40针，这些针里面最重要的就是GPIO针了，GPIO翻译过来就是通用输入输出针脚，具体哪根针什么作用我还真没了解透，但已经足以让我完成正常的接线工作了。 接线时，比较困扰我的一点就是GPIO针的顺序不是固定的，每次接线都要对照着针脚图去做。我这里有一个简便的办法就是接线时在树莓派的命令行打上pinout，然后就会出现针脚对应的GPIO编号，比自己一直保存一张图片要方便一点。 上面的图片就是命令行里出来的内容，其中3V3表示3.3伏的电压，红色的5V当然就是5伏电压了。然后GND表示接地，剩余的绿色针脚就都是GPIO接口了。 这里想提一点的是我刚拿到树莓派给它装上外壳后，上面有一个附带的小风扇不论我怎么接都不会转，我都以为是坏掉了呢。结果查了这些针脚的作用之后，我把红线接正极，黑线接地，风扇就顺利的转起来了。。。 二、开始接线？在接线的时候，我也遇到了一些困扰。商家送了我面包板和排线，我也听人说面包板和排线会让自己接线更加方便一点，但我双手拿着这两样东西时，却不知道要怎么组装在一起了。。 后面看了一个教程之后才明白，要用排线将树莓派和T型板连上，然后在将T型板和面包板连上，也就是下图这样： 但当我要将排线连到树莓派上时，却发现加装了外壳的树莓派放不下这一块排线。。。无良商家啊，，我都买的是套餐了，你的配件竟然还不配套，气死我啦。难道我每次接线都要拆外壳吗？ 最终我放弃了使用面包板，一是因为要拆外壳，二是因为我没有可以插在面包板上的针😂那就只好采用直接接线大法了。 三、正式开始先亮出我的低电平触发有源蜂鸣器，即它会在低电平时发出固定频率的声音。 它上面有三个脚，GND接地，VCC接电源，一般接树莓派上的3.3V电源即可（接5V没有电阻的话我可不敢保证它会不会坏掉。。）。中间的那个IO就是接树莓派的GPIO口的，这里由于我的python程序是网上找的，也懒得改，就直接用它定义的GPIO口了。 alarm.py 123456789101112131415161718192021222324252627import RPi.GPIO as GPIOimport time# GPIO 口为17trig=17 def init(): GPIO.setwarnings(False) GPIO.setmode(GPIO.BCM) GPIO.setup(trig,GPIO.OUT,initial=GPIO.HIGH) pass def beep(seconds): GPIO.output(trig,GPIO.LOW) time.sleep(seconds) GPIO.output(trig,GPIO.HIGH) def beepBatch(seconds,timespan,counts): for i in range(counts): beep(seconds) time.sleep(timespan) init()# 修改下面这一行的参数beepBatch(0.2,1,3) GPIO.cleanup() 上面的程序会在蜂鸣器发出三次短暂的鸣响后自动退出，我们在连线之后可以修改前两个参数来控制鸣响时长和间隔时间，以此来测试我们程序是否运行成功。 下面就开始正式的接线了，其实这就比较简单了。我用红色线表示电源线，黑色线表示地线，然后随便一个颜色线表示GPIO线，查阅针脚对应GPIO图，可知GPIO17对应第11个接口。 请忽略背景中小风扇的线。。。 接好之后，在树莓派中运行命令： 1sudo python alarm.py 然后你就可以听到悦耳的三声鸣响了～ 后记无意中看到无源蜂鸣器可以播放音乐，我就想到每次别人生日，生日蛋糕中带的那个东西都可以响好长时间，好烦好烦。我也好想做一个这么烦的东西啊，可是手里没设备～ 还有就是遇到开发要在自己电脑开发，调试要在别的电脑调试的情况，可以在VSCode上装一个sftp插件，这样当你保存文件时就会自动上传到服务器，十分好用。 最后想说的是，我还有这么多传感器要把玩呢，有兴趣的话要关注我欧～]]></content>
      <tags>
        <tag>有源蜂鸣器</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS 无需代码实现TableViewCell自适应高度]]></title>
    <url>%2F2019%2F11%2F19%2Fios-tableview-cell-autoheight%2F</url>
    <content type="text"><![CDATA[最近开始入门IOS开发了，本来打算用以前的方式自学的，但发现找不到什么好的视频教程，最后只好花钱买了一个基础教程，算是入门了IOS开发吧。 花了一个星期差不多学完教程之后，打算做一个文本编辑器，那么首先要有一个列表，我希望能够显示文章的标题以及开头的几行内容，但我发现要做到显示简介还并不是一个容易的事情。 不过最终还是实现了自适应高度的效果，下面先放上效果图： 下面正式开始我的探索之旅。（如果不想看前面的铺垫可直接跳到第二节） 一、实现TableView并使用自定义Cell首先拖一个TalbeViewController到页面中并指定入口，然后⌘+N创建一个对应的TableViewController实现类PostController.swift，并在TableView的页面中连接上该类。 PostController此时应该有Xcode自动帮我们生成的一些代码，我们现在需要设置一下TableView的数据源： 123456789101112131415161718// 设置 tableView 有几部分override func numberOfSections( in tableView: UITableView) - &gt; Int &#123; return 1&#125;// 设置 tableView 有几行override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) - &gt; Int &#123; return 5&#125;// 设置t tableView 的单元格内容override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) - &gt; UITableViewCell &#123; // 根据单元格上定义的 identifer 识别对应的单元格 let cell = tableView.dequeueReusableCell(withIdentifier: "postItem", for: indexPath) cell.textLabel?.text = "我是修改后的内容" return cell&#125; 上面代码中用到了TableCell的标识符postItem，我们需要在界面中定义一下： 然后按下⌘+R运行项目，得到的结果如下： 这样就得到了最基本的TableView样式了，但显然不能满足我的要求。所以需要将TableCell的类型改为自定义类型。 此时我们需要新建一个类继承TableViewCell，以便我们对这个自定义Cell进行操作。 ⌘+N新建CocoaTouchClass，并继承UITableViewCell： 创建完成后，同样需要将界面中的TableCell和代码连接起来。连接成功后，应该就可以在代码助手中找到该类： 然后我们先按照预想的方式来实现两个Label的TableCell。 这样设计之后乍一看应该是能满足要求了吧？运行起来看看： 发现只显示了第一个Table，第二个却没有显示。 二、自定义TableCell实现自适应高度遇到这种情况，我第一个想到的就是TableView有没有自动高度的功能呢？找了一下发现TableView和TableCell里面都有这个属性，但我开启了之后也没有作用。然后求助百度，一堆代码实现的方法，看不下去啊。实在不甘心，就去求助谷歌，结果在这个网站上找到的方法：http://www.thomashanning.com/uitableview-automatic-row-height/ 总的来说就是要给TableCell里面的内容添加约束，使其上下左右四个方向均存在和父元素的约束，然后再让TableCell里面的内容可以动态改变大小。然后我自己试了一下，确实是有用的，但当我换成两个元素在四个方向上的约束时，却又失效了。 于是我想到可以用StackView将两个元素整合成一个元素，所以下面就是我的做法： 1、选中两个Label，将其合并为一个Label 2、给合并后的StackView添加四个方向的约束，距离均为0 设置完成后，由于StackView的四条边均和外部有了约束，里面的两个Label的高度就不能确定了。而我们的目标是第一个Label的高度固定为1行，而第二个Label的高度随内容变化，且最多显示3行。那么我们就需要给第一个Label添加高度的约束。 再次运行项目，即可看到第二个Label出现了。 因为目前的内容是静态的，所以不能确定这样做是否实现了自适应高度。而这一点就需要你们用代码来验证一下了，至少我是验证通过了～～]]></content>
      <tags>
        <tag>IOS开发</tag>
        <tag>TableViewCell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这个微信浏览器跳转技巧，每个月能帮你省几百块]]></title>
    <url>%2F2019%2F10%2F22%2Fwx-jump%2F</url>
    <content type="text"><![CDATA[在微信公众号开发中，不可避免地要遇到下载软件、支付宝支付等需求，而这些需求都是无法在微信浏览器内部实现的，那么在微信浏览器内自动跳转到外部浏览器就是一个刚需了。 百度一下微信跳转，可以发现大部分结果都被这些跳转平台承包了。 这张图片不知道为什么被删掉了，那就不添加了。大家可以自行搜索看看。 然后打开一个还可以用的跳转平台，可以看到最主要的功能就是： IOS微信会提示用户右上角打开浏览器（这谁还不会提示呀） 安卓微信则是自动用默认浏览器打开链接（我们主要就是实现安卓端的自动跳转功能） 然后看了一下价格，500块？一个月？最低？溜了溜了溜了。 不过穷人也有穷人的办法，这些平台显然没有和微信合作，那么他们是怎么做到这个跳转功能的呢？我们需要跟踪调研一番。。。 打开这个平台的演示二维码，我的是苹果手机，扫描之后确实只显示了请点击右上角选择Safari打开的提示。 然后我解析了这个二维码，得到一个地址，直接在浏览器打开。哇噻，神奇呀，竟然跳到百度了。 经过以上步骤，已经验证了以下两点： 苹果手机确实只能用户手动打开浏览器 普通浏览器可以直接跳转到指定页面 那么现在需要验证的就是安卓微信里面打开这个网页是否可以跳转到外部浏览器并打开指定页面。 不过在此之前，我们先对普通浏览器打开这个网页的所有请求进行抓包，稍后比较与安卓微信打开这个网页的请求进行比较，看看两者是不是有哪些不一样的地方导致了安卓微信可以跳转到外部浏览器而不是直接打开页面。 先看第一个请求，这是我们解析的网址，然后重定向到了http://jumpqq.doupie.cn这个网址，看域名可以发现，这应该是一个新浪微博的短网址生成工具，最后的jumpqq.doupie.cn才是我们真正跳转到的地址。 然后在这个真正的网址中，它又重定向到了www.baidu.com，也就是刚刚我们看到的页面。 分析了普通的浏览器跳转流程之后，我们来验证和分析一下安卓微信浏览器里面的跳转流程。 打开genimotion模拟器并安装微信，然后随便找个聊天框输入刚刚解析出来的网址并打开，可以发现确实是自动弹出了跳转浏览器的选项（我没有设置默认浏览器，如果设置了会直接使用默认浏览器打开）。 现在问题来了，怎么抓包呢？ 在Chrome浏览器地址栏输入chrome://inspect/#devices打开设备管理界面，如果此时你的微信浏览器还没有关掉的话，稍等一下应该可以看到一个页面在手机下面的列表中。 Tips:使用这个调试功能需要FQ，如果没有FQ的话是可以显示这个页面但无法打开具体页面的开发者工具的。 下面还有一个问题，只有手机里面已经打开了页面这个列表里面才会显示，我们才能去抓包。而我们要分析的主要就是打开这个页面之前的请求流程，此时我们在自己电脑上编写一个HTML文件并放到Nginx服务器上，页面里面就放一个链接，指向刚刚的那个网址。这样的话就是先打开自己写的页面，然后电脑上打开该页面的调试工具，然后点击刚刚的链接就可以成功抓到我们需要的请求了。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-hans"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="ie=edge, chrome=1"&gt;&lt;title&gt;微信跳转测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://sinaurl.cn/AiYTFMTB"&gt;下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在微信中输入并打开我们刚刚写的页面（地址要用电脑的局域网地址），先不要点击下载，等待Chrome浏览器设备调试页面出现这个页面之后，点击标题下方的inspect,等待片刻即可看到熟悉的开发者工具了。 然后把开发者工具切换到Network一栏。 在模拟器中点击下载这个超链接 然后来分析这次请求中究竟有什么是和普通浏览器的请求是不同的： 第一步还是短网址的重定向，和普通浏览器流程相同。 但在真正跳转的网址里面就有不同之处了，首先状态码变成了206，然后Headers里面还多了一个Content-Disposition属性，那么我想应该就是这两处不同导致可以在安卓微信里跳转到外部浏览器了。 百度百科HTTP状态码206含义（部分）： 206 Partial Content服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 MDN Content-Disposition含义： 在常规的HTTP应答中，Content-Disposition`响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。 作为消息主体中的消息头 在HTTP场景中，第一个参数或者是inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将filename的值预填为下载后的文件名，假如它存在的话）。 查阅上方资料得知这两个东西都是在告诉微信浏览器，我接下来要做的事你干不了，赶紧找个专业的来干吧。 理解了关键点之后，也就知道要做到跳转这个功能，最重要的是服务端的响应，我这里就以Nginx为例，配置了当请求来自微信浏览器时，就把某个路径下的页面响应加上特殊的请求头： 123456789101112131415161718server &#123; listen 80; location / &#123; root html; &#125; # 指定目录下的文件 location /test/ss/ &#123; # 微信内置浏览器 if ($http_user_agent ~* (MicroMessenger)) &#123; add_header Content-Type &quot;text/plain; charset=utf-8&quot;; add_header Content-Disposition &quot;attachment;filename=open.apk&quot;; return 206; &#125; &#125; &#125; 然后就在test目录下新建一个ss目录，然后放上我们要跳转的页面（即微信会屏蔽的页面），随便写点内容，然后修改我们刚刚的“首页”，把地址换为这个随便写的页面地址。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-hans"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="ie=edge, chrome=1"&gt;&lt;title&gt;微信跳转测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://192.168.3.132/test/ss/toc.html"&gt;下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 然后尝试在微信里面打开这个链接，就可以实现跳转浏览器的效果了。 至此，主要功能已经实现了，但还有一个短网址生成服务，我们可以用下面这个网站提供的服务，不仅可以手动输入，还提供API生成，可以说十分良心了。 http://www.sina-url.cn/ 下面写一下我想的微信跳转功能的完整思路： 根据上面的思路，还有一些做法需要完善： 服务端判断安卓微信 1234567891011121314151617# nginx不支持&amp;&amp;和||和if嵌套，通过变量来解决set $flag 0;if ($http_user_agent ~* MicroMessenger)&#123; set $flag “$&#123;flag&#125;1”;&#125;if ($http_user_agent ~* Android)&#123; set $flag “$&#123;flag&#125;1”;&#125;# 此时，如果有一个为真，flag=01，全部为真，flag=011if ($flag = &quot;011&quot;) &#123; add_header Content-Type &quot;text/plain; charset=utf-8&quot;; add_header Content-Disposition &quot;attachment;filename=open.apk&quot;; return 206;&#125; js判断微信浏览器 12345678function is_weixn()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)=="micromessenger") &#123; return true; &#125; else &#123; return false; &#125; &#125; 这样一整套流程下来，就实现了区分不同设备，对于可以自动跳转设备进行跳转了。 怎么样？我不是一个标题党吧，嘿嘿]]></content>
      <categories>
        <category>用就对了</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FRP内网穿透一站式配置]]></title>
    <url>%2F2019%2F09%2F24%2Ffrp-01%2F</url>
    <content type="text"><![CDATA[FRP内网穿透一站式配置场景1：我有一台配置很差的服务器，也有一台放在公司可以一直开机的电脑，我想跑一个springboot项目。 场景2:我要做微信开发，我必须要有一个公网可以访问的域名。 针对这两种场景，要怎么做呢？当然是使用内网穿透，而市面上好的内网穿透工具收费，免费的每次建立的域名都是随机的，那能不能自己搭一个内网穿透服务呢？当然可以！ 一、FRP安装frp是一款开源的内网穿透软件，可以在GitHub上找到：https://github.com/fatedier/frp。 readme中有中文文档的链接，在release中可以看到最新的版本0.29.0 。其中我需要的是Linux版本的、Windows版本的和Mac版本的，目前我们的电脑大部分都是64位的了，我选择下载的分别是以下几个文件： 1、Linux服务端安装我的服务器是CentOS 7，可以直接通过命令下载，也省去了文件上传的步骤： 1wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz 解压文件： 1tar -zxvf frp_0.29.0_linux_amd64.tar.gz 删除我们不需要的客户端文件： 1234cd frp_0.29.0_linux_amd64ls -arm frpcrm frpc.ini 打开服务端配置文件： 1vim frps.ini 将文件内容换为下面的： 1234567[common]bind_port = 7000dashboard_port = 7500token = bobozuihaodashboard_user = admindashboard_pwd = bobozuihaovhost_http_port = 8080 端口号均采用默认值即可，上面字段的含义如下： 名称 含义 bind_port 服务端口号 token 客户端服务器之间的密钥 dashboard_port frp仪表盘端口号 dashboard_user admin dashboard_pwd 仪表盘密码 vhost_http_port web服务代理端口号 按下esc 键进入命令模式，保存并退出当前文件： 1:wq 然后运行服务端： 1./frps -c frps.ini 此时访问服务端x.x.x.x:7500即可访问FRP仪表盘。 这张截图是配置过Nginx重定向之后的仪表盘页面 2、Linux服务端后台运行FRP在上一节中我们成功运行了FRP，但我们按Ctrl+C退出或关闭SSH窗口后，FRP均会停止运行，此时我们需要使用nohup将其运行在后台。 1nohup ./frps -c frps.ini &amp; Ctrl+C关闭nohup并查看后台中是否有FRP： 123jobs# 下面是显示结果[1]+ Running nohup ./frps -c frps.ini &amp; 3、Windows及Mac安装客户端Windows和Mac就需要手动下载了，对于用浏览器下载GitHub文件的下载速度真的不敢苟同，不过Windows上可以用freedownloader下载，Mac上用aria2下载，相比之下速度真的很感人了。 将下载后的文件解压，并删除服务端的文件。 然后对frpc.ini进行如下配置： 123456789101112131415[common]server_addr = 66.42.62.8server_port = 7000token = bobozuihao[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[web]type = httplocal_port = 8080custom_domains = web.frp.aqzscn.com 最主要的就是common的配置和web的配置了,根据我的观察，这个文件是根据[xxx]来划分范围的，如果要开启多个不同的映射，多声明几个不同名字的[xx]模块就行。 因为我是在Mac上测试的，nginx的默认端口就是8080，然后修改nginx的欢迎页为this is Redirect Page以示和服务器上的默认页面的不同。 命令行输入.\frpc -c frpc.ini即可与服务端连通，访问刚刚配置的web.frp.aqzscn.com即可访问到我们本地的欢迎页了。 这张截图是映射到Windows上运行的Restful服务的页面。 4、功能点补充上面的两张截图中，域名后面均没有加端口号，这是因为我在服务端配置了nginx转发的缘故。 首先我希望我的域名frp.aqzscn.com 作为我的frp仪表盘页面，而*.frp.aqzscn.com则是客户端配置的各种映射地址，那么我需要先去域名服务提供商那里修改我的dns配置，增加两条A记录，或者索性配置一条A记录*.aqzscn.com转发到服务器的80端口，然后所有转发就可以放在服务器的nginx上了。 下面贴出我的nginx配置供大家参考： 12345678910111213141516171819202122232425262728293031323334server &#123; listen 80; server_name 127.0.0.1 aqzscn.com www.aqzscn.com; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125;server &#123; listen 80; server_name frp.aqzscn.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:7500/; &#125;&#125;server &#123; listen 80; server_name *.frp.aqzscn.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; &#125;&#125; 其中用server_name来匹配对应的域名，proxy_set_header 来保证请求的头信息和原始的头信息是一致的。 二级域名配置上面只是实现了简单的一个域名的映射，如需映射多个域名，就需要配置二级域名了。 配置服务端： 1vi frp_0.29.0_linux_amd64/frps.ini 1subdomain_host = frp.aqzscn.com 重启FRP服务： 1234567891011121314# 一般来说，可以通过jobs列出当前会话中的进程，然后kill %【序号】，但我是新建立的ssh连接，所以只能通过第二种方式了。# 列出与frps有关的进程ps -aux|grep frps# root 7415 0.0 2.5 114076 25248 ? Sl Sep19 0:06 ./frps -c frps.ini# root 28113 0.0 0.2 112724 2240 pts/0 S+ 13:34 0:00 grep --color=auto frps# 然后杀掉对应的进程号kill 7415kill 28113# -bash: kill: (28113) - No such process# 用nohup启动frpsnohup ./frps -c frps.ini &amp; 配置客户端： 12345[mweb]type = httplocal_port = 8080subdomain = test;这是ini文件的注释，我们可以在一个配置文件中配置多个web服务的重定向，并通过注释来关闭和开启对应的映射。 然后启动客户端，并访问我们配置的地址：http://test.frp.aqzscn.com/ 可以明显地看到这是我们本地的网页。]]></content>
      <categories>
        <category>用就对了</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS快速安装SSR]]></title>
    <url>%2F2019%2F09%2F24%2FCentOS%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85SSR%2F</url>
    <content type="text"><![CDATA[安装步骤1、下载安装包1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh 2、修改安装脚本权限1chmod +x shadowsocksR.sh 3、配置SSR12./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log// 之后会让配置密码等信息，我们自定义一下密码之后，剩下的都直接回车用默认值就行。 配置信息一定要保存起来，否则找起来太麻烦了。。 开启BBR加速1、下载安装包1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 2、获取权限1chmod +x bbr.sh 3、开始安装12./bbr.sh// 这一步之后会让重启，确定即可 4、验证安装状态1lsmod | grep bbr BBR 加速有点坑，开启就不能连接了，建议不要开启！！！]]></content>
      <categories>
        <category>用就对了</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CenOS 快速安装 Nginx]]></title>
    <url>%2F2019%2F09%2F24%2FCenOS-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85-Nginx%2F</url>
    <content type="text"><![CDATA[安装过程1、将nginx放到yum repro库中1rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2、查看nginx信息1yum info nginx 3、使用yum安装ngnix12yum install nginx// 中途需要输入 y 确认安装 4、启动nginx1service nginx start 5、查看nginx版本1nginx -v 6、访问nginx1curl -i localhost 常用命令1、nginx配置文件目录1ll /etc/nginx/ 2、修改nginx配置文件1vim /etc/nginx/conf.d/default.conf 3、重启服务1/usr/sbin/nginx -s reload 4、停止服务1/usr/sbin/nginx –s stop 5、测试配置文件是否正常1/usr/sbin/nginx –t 外网不能访问的问题查看并关闭防火墙 1234systemctl status firewalld.servicesystemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl status firewalld.service CenOS 服务常用命令1、启动一个服务1systemctl start firewalld.service 2、关闭一个服务1systemctl stop firewalld.service 3、重启一个服务1systemctl restart firewalld.service 4、显示服务状态1systemctl status firewalld.service 5、开机时启用一个服务1systemctl enable firewalld.service 6、开机时禁用一个服务1systemctl disable firewalld.service 7、查看服务是否开机启动1systemctl is-enabled firewalld.service;echo $? 8、查看已启动的服务列表1systemctl list-unit-files|grep enabled]]></content>
      <categories>
        <category>用就对了</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（三）]]></title>
    <url>%2F2019%2F07%2F22%2Fwechat-account-03%2F</url>
    <content type="text"><![CDATA[上一篇文章基本上把技术上的实现都讲了一遍，证明实现这个功能是切实可行的。下面就对建好的服务雏形进行完善和增加功能。 先放这个系列的文章： 微信公众号制作记账功能（一） 微信公众号制作记账功能（二） 一、默认回复前面设置的默认回复就是简单的一句话，一点都不够智能，当然了，我再怎么改造，只要不用到聊天机器人这种功能，那就不会特别智能。但聊天机器人的API都是要收费的哎，而如果我用python在服务器上自己搭一个，那我真怕服务器会受不了这么大的压力。 那要怎么办呢？至少每次给用户的回复都不一样吧。这时我想到了hitokoto这个API，接口基本上没什么限制，每次都会返回一个新的句子，挺适合我的需求的。 下面新建/api/api.js，用于请求接口数据： 12345678910111213141516171819202122// 此处放置有关请求API接口的代码var request = require('request')// 获取一言数据const getHitokoto = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; request(&#123; method: 'GET', url: 'https://international.v1.hitokoto.cn/' &#125;, (err, res, body) =&gt; &#123; if (res) &#123; resolve(JSON.parse(body)) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;module.exports = &#123; getHitokoto&#125; 请求接口有了，下面就要使用这个接口，这里用到上篇文章说的链式调用处理信息。首先建立/service/default.js，这里同样要实现功能的分发，因为后面可能会为默认回复增加不同的功能。 1234567891011121314151617181920212223242526272829303132var db = require('./db')var api = require('../api/api')// 功能分发const doQuery = (payload) =&gt; &#123; if (payload.Content === '一言' || payload.Content === 'hitokoto') &#123; return returnHitokoto(payload, true) &#125; else &#123; return returnHitokoto(payload) &#125;&#125;// 获取一言const returnHitokoto = (&#123;FromUserName, CreateTime, Content&#125;, isTarget = false) =&gt; &#123; return api.getHitokoto().then(data =&gt; &#123; let tips = '' if (!isTarget) &#123; tips = '主人我太笨了，没有明白你的意思。不过我准备了一句话，你看你喜不喜欢？\n\n' // 构造未识别对话记录 const unknownWord = &#123; openid: FromUserName, content: Content, createTime: CreateTime &#125; db.unkonwnDb.insert(unknownWord) &#125; const msg = `$&#123;tips&#125;$&#123;data.hitokoto&#125;\n\nby $&#123;data.from&#125;` return msg &#125;)&#125;module.exports = doQuery 因为获取一句话同样是一个小功能，所以就先判断是否是专门获取一句话的，如果是的话，就不再添加我不懂我不懂之类的废话了，哈哈。 然后就是链式调用的实现了： 123456789101112131415// 普通文字消息 moneyManager.doQuery(json.xml).then(msg =&gt; &#123; if (msg) &#123; return msg &#125; else &#123; return defaultFilter(json.xml) &#125; &#125;).then(msg =&gt; &#123; // ... resbody = jParser.parse(tempBody) res.send(resbody) &#125;).catch(error =&gt; &#123; console.error(error) res.send('服务器发生异常，请联系微信号aqzscn解决') &#125;) 可以这么做的原因是如果上一个过滤器匹配到命令，它的返回值就不会为空，反之则会为空。这里当然是用的最笨的过滤器实现方式–手动添加，不过至少功能是实现了。 然后就可以尝试发送一条系统不懂的消息了： 怎么样？效果还可以吧 但这时我遇到一个问题，我请求hitokoto源是要消耗一段时间的，但微信服务器等不及呀，它就启动了它的三次重试机制。那我就只好增加一个过滤机制了，打开app.js，在系统启动时新增一个全局变量： 12// 定义缓存消息id的数组,防止重复响应global.tempMsg = [] 然后在/routes/wx.js中先判断是否是重复消息，不是的话才允许向下执行： 123456789101112131415161718192021222324// 因为系统还会请求其他服务器，返回可能会有延时，因此在这里判断并保存每个消息的openid和msgid(可能是在if语句外面，不过目前只是处理文字信息，先不考虑那么多了吧) let mIndex = -1 global.tempMsg.some((item, index) =&gt; &#123; if (item.openid === openid &amp;&amp; item.msgid === json.xml.MsgId) &#123; mIndex = index return true &#125; &#125;) if (mIndex &gt;= 0) &#123; res.send(resbody) return &#125; else &#123; mIndex = global.tempMsg.length // 添加到缓存 global.tempMsg.push(&#123; openid: openid, msgid: json.xml.MsgId &#125;) &#125;// ...// 在请求执行完之后，再将缓存中的数据删除global.tempMsg.splice(mIndex, 1) 这样就能防止重复对一个请求做出响应了。但不足的是代码实现不够优雅，后面应该增加一个前置过滤器来处理这种事情。 二、账单分页这个功能的实现就比较简单了，预期的实现效果是： 12345请求：账单回复：第一页账单请求：账单2回复：第二页账单 首先就是对功能分发的改造： 12// 匹配以账单开头的命令if (payload.Content.indexOf('账单') === 0) 查询账单时就是多了一个计算页数的过程，然后分页的逻辑nedb中已经有了，直接用就是了： 12345678910111213141516171819202122232425262728// 查询账单const queryBill = (&#123;FromUserName, CreateTime, Content&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let pageIndex = 0 if (Content.length &gt; 2) &#123; const temPage = parseInt(Content.replace('账单','')) if (temPage) &#123; pageIndex = temPage &#125;else &#123; res('') return &#125; &#125; if (pageIndex &gt; 0) &#123; pageIndex-- &#125; db.moneyDb.find(&#123;openid: FromUserName&#125;).sort(&#123;recordTime: -1&#125;).skip(pageIndex * config.billRows).limit(config.billRows).exec((err, docs) =&gt; &#123; let str = '' docs.forEach(item =&gt; &#123; const d = dateUtil.getNowSimpleFormatDate(new Date(item.recordTime * 1000)) const s = `[$&#123;d&#125;] $&#123;item.type&#125; $&#123;item.price&#125;元\n` str += s &#125;) const msg = str ? ('您的账单如下:\n' + str + '\n回复【账单+数字】可翻页') : '没有查询到账单哦~' res(msg) &#125;) &#125;)&#125; 然后就有了这种效果： 刚刚在正式的公众号看时间显示有点问题，待会儿看看怎么回事。 三、统计功能统计功能的预期实现效果： 12345请求：统计回复：当天收支情况请求：统计2回复：近2天收支情况 这个功能也是很简单就能实现的： 123456789101112131415161718192021222324252627282930313233343536373839// 匹配统计开头的命令fun doQuery:if (payload.Content.indexOf('统计') === 0) &#123; // 统计const tongji = (&#123;FromUserName, CreateTime, Content&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let dayIndex = 0 if (Content.length &gt; 2) &#123; const temday = parseInt(Content.replace('统计','')) if (temday &amp;&amp; temday &gt;= 0) &#123; dayIndex = temday &#125;else &#123; res('') return &#125; &#125; const now = new Date(CreateTime * 1000) now.setDate(now.getDate() - dayIndex) const d = dateUtil.getStartOfDay(now) db.moneyDb.find(&#123; recordTime: &#123; $gt: d.getTime()/1000 &#125;, openid: FromUserName&#125;, (err, docs) =&gt; &#123; // 定义结余、收入、支出 let remain = 0 let reward = 0 let cost = 0 docs.forEach(item =&gt; &#123; remain += item.yk * item.price if (item.yk &gt; 0) &#123; reward += item.price &#125; else &#123; cost += item.price &#125; &#125;) const dayTxt = dayIndex === 0 ? '当天' : `近$&#123;dayIndex&#125;天` const msg = `$&#123;dayTxt&#125;的收支情况如下：\n【结余】: $&#123;remain&#125; 元\n【收入】: $&#123;reward&#125; 元\n【支出】: $&#123;cost&#125; 元` res(msg) &#125;) &#125;)&#125; 然后实现效果如下： 四、固定开支我们每个月都会有固定开支，如工资、花呗、分期，这些固定的项目其实是不需要用户手动去输入的，系统完全可以帮用户做到。 预期效果： 12345678请求：月开销预设回复：请输入\n示例：【1工资2000】【2分期还款-500】\nTips:文字前的数字为每月几日，只支持1-28，不填写默认为1日==================30分钟内未回复则放弃当前指令==================请求：1工资1999回复：设置成功\n每月1日工资收入1999 要实现这样的效果，就要缓存用户上一步的指令，并且要知道指令的总步骤数量及当前进行到哪一步。 既然缓存了，就要有删除的步骤，一种方式是定义一个定时器，每隔一段时间清除失效的指令。另一种方式是在用户下一次请求时判断指令是否失效，如果失效就重新开始。 这里也要考虑到如果用户一直不发下个请求呢？难道服务器要一直缓存直到内存爆炸？所以定时器一定要有，但太频繁也不好，所以还是要在读取指令前判断用户之前的指令是否失效。 其实到现在这个步骤，整个后台应用就显得有点复杂了，我们必须要把过滤器的思路贯彻到底，重新改写响应逻辑，实现路由入口处的简洁。 首先，路由入口会收到两种消息类型：普通消息及事件推送，为了区分它们，我们先建立消息类型分发器msgTypeDispatcher.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const config = require('../config/index')const moneyManager = require('./money')const defaultManager = require('./default')const doDispatch = (payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 通过MsgType区分事件还是普通消息 if (payload.MsgType !== 'event') &#123; resolve(doNormalMsgPreFilter(payload)) &#125; else &#123; resolve(doEventMsgPreFilter(payload)) &#125; &#125;)&#125;// 普通消息的前置过滤器const doNormalMsgPreFilter = (payload) =&gt; &#123; // 判断系统是否正在处理该消息 let mIndex = -1 global.tempMsg.some((item, index) =&gt; &#123; if (item.openid === payload.FromUserName &amp;&amp; item.msgid === payload.MsgId) &#123; mIndex = index return true &#125; &#125;) if (mIndex &gt;= 0) &#123; // 如果正在处理，直接返回 return 'success' &#125; else &#123; mIndex = global.tempMsg.length // 添加到缓存，表示系统正在处理 global.tempMsg.push(&#123; openid: payload.FromUserName, msgid: payload.MsgId &#125;) &#125; if (payload.MsgType === 'text') &#123; return moneyManager.doQuery(payload).then(msg =&gt; &#123; if (msg) &#123; return msg &#125; else &#123; return defaultManager.doQuery(payload) &#125; &#125;).then(msg =&gt; &#123; return doNormalMsgSufFilter(mIndex, msg) &#125;) &#125; else &#123; return doNormalMsgSufFilter(mIndex, '不支持的消息类型') &#125;&#125;// 普通消息的后置过滤器const doNormalMsgSufFilter = (index, msg) =&gt; &#123; // 最终请求会走到这里，在这里从缓存中删除该消息 global.tempMsg.splice(index, 1) return msg&#125;// 事件消息的前置过滤器const doEventMsgPreFilter = (payload) =&gt; &#123; // 暂时不需要对事件有额外操作，判断事件类型后直接返回结果即可 if (payload.Event === 'subscribe') &#123; return subscribe() &#125; else if (payload.Event === 'unsubscribe') &#123; return unsubscribe() &#125; else &#123; return '不支持的事件类型' &#125;&#125;// 处理关注事件const subscribe = () =&gt; &#123; return config.banner&#125;// 处理取消关注事件const unsubscribe = () =&gt; &#123; return ''&#125;module.exports = doDispatch 将消息分发的逻辑抽取出来之后，/routes/wx.js接口的代码就变得非常简洁了： 12345678msgDiapatcher(json.xml).then(msg =&gt; &#123; tempBody.xml.Content = msg &#125;).catch(error =&gt; &#123; console.error(error) tempBody.xml.Content = '系统运行出错，请联系微信号aqzscn解决' &#125;).finally(() =&gt; &#123; res.send(jParser.parse(tempBody)) &#125;) 因为设定固定开支的步骤一共需要两步，那么我们就要保存上一步的状态，为了统一所有具有多个步骤的操作，新增一个步骤过滤器，在过滤器中可以直接执行相应步骤的代码。而且为了方便以后拓展，通过设定step来判断步骤执行到第几步。 123456789101112131415161718192021222324252627282930313233343536373839404142const presetManager = require('./preset')const garbageManager = require('./garbage')const doFilter = (payload) =&gt; &#123; // 判断用户是否正在执行上一步操作 let index = -1 global.stepMsg.some((item, idx) =&gt; &#123; if (item.openid === payload.FromUserName) &#123; index = idx return true &#125; &#125;) if (index &lt; 0) &#123; return '' &#125; else if (payload.Content === 'q') &#123; // 从缓存中移除该命令 global.stepMsg.splice(index, 1) return '已恢复正常模式' &#125; // 进入到指定的命令中 return new Promise((resolve, reject) =&gt; &#123; // 更新步骤消息的最后时间 global.stepMsg[index].time = Math.ceil(new Date().getTime() / 1000) switch (global.stepMsg[index].command) &#123; case 'setKz': const msg = presetManager.setKz(payload, global.stepMsg[index].step) // 从缓存中移除该命令 global.stepMsg.splice(index, 1) resolve(msg) break; case 'queryGarbage': resolve(garbageManager.queryStep(payload, global.stepMsg[index].step)) break; default: resolve('') &#125; &#125;)&#125;module.exports = &#123; doFilter&#125; 建立完成后在消息分发器中调用： 123456if (payload.MsgType === 'text' || payload.Content) &#123; // 首先执行步骤过滤器 const filterRes = stepFilter.doFilter(payload) if (filterRes) &#123; return filterRes &#125; 经过上面的处理，步骤消息就能到达指定的方法中，并且该方法也不必去管怎么去缓存当前步骤，怎么去删除缓存的事情，在我看来还算是一个较好的解决方案。下面把处理固定开支的代码放上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const db = require('./db')const doQuery = (payload) =&gt; &#123; if (payload.Content === '月收支预设') &#123; return setKz(payload) &#125; else if (payload.Content === '查询收支预设') &#123; return queryPreset(payload) &#125; else &#123; return '' &#125;&#125;// 预设开支const setKz = (&#123;FromUserName, CreateTime, Content&#125;, index = 0) =&gt; &#123; let msg = '' switch (index) &#123; case 0: // 将该用户的命令设置到缓存中 global.stepMsg.push(&#123; openid: FromUserName, step: 1, command: 'setKz', time: CreateTime &#125;) msg = '请输入\n示例1：【1工资2000】\n示例2：【2分期还款-500】\nTips:文字前的数字为每月几日，只支持1-28，不填写默认为1日' break; case 1: const dayReg = Content.match(/^\d&#123;1,2&#125;/) const titleReg = Content.match(/[^\d-]+/) const priceReg = Content.match(/-?\d+$/) if (titleReg &amp;&amp; priceReg) &#123; const day = dayReg ? parseInt(dayReg[0]) : 1 const title = titleReg[0] const price = parseInt(priceReg[0]) if (day &lt; 1 || day &gt; 28) &#123; msg = '为保证程序正常执行，只允许在每月1日到28日设置固定收支' &#125; else &#123; const kz = &#123; openid: FromUserName, day: day, title: title, money: price &#125; db.presetDb.insert(kz) msg = `设置成功！\n将于每月$&#123;day&#125;日自动添加账单【$&#123;title&#125; $&#123;price&#125;元】` &#125; &#125; else &#123; msg = '信息匹配失败，请检查是否符合【1工资2000】的格式' &#125; break; default: msg = '预设收支命令匹配失败' break; &#125; return msg&#125;// 查询收支预设const queryPreset = (&#123;FromUserName&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; db.presetDb.find(&#123;openid: FromUserName&#125;).sort(&#123;day: 1&#125;).exec((err, docs) =&gt; &#123; if (docs) &#123; let msg = '您的预设信息如下：\n' docs.forEach(item =&gt; &#123; const zy = item.money &gt; 0 ? '增加' : '扣除' const money = Math.abs(item.money) msg += `每月$&#123;item.day&#125;日 $&#123;zy&#125;【$&#123;item.title&#125;$&#123;money&#125;元】\n` &#125;) resolve(msg) &#125; else &#123; resolve('没有查询到您预设的收支\n回复【月收支预设】来设置一笔吧') &#125; &#125;) &#125;)&#125;module.exports = &#123; doQuery, setKz&#125; 最后的实现效果就是： 当然，这样只是实现了记录的功能，那么自动执行任务还没有做。我的预想是每晚3点定时去判断每个用户当天的收支预设信息，如果是当天，则向账单中添加记录。又因为项目中不可能只有这一个定时器，因此干脆一了百了，再做一个定时器管理的功能。 js中与定时有关的也就是setTimeout和setInterval了，而且现在需要做的也只是定时（整点）执行任务，那么我们就可以计算当前时间距离下一个整点还有多久，然后setTimeout到下一个整点（也可以是下下个整点，计算时间并相加即可），启动setInterval执行我们真正需要执行的任务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const presetTimer = require('./presetTimer')const config = require('../../config/index')const stepTimer = require('./stepTimer')let i = 1const timeDefine = config.taskTimerConfigconst init = () =&gt; &#123; // 测试功能 // test() // 一天的时间 毫秒数 const dayTimeStamp = 60 * 60 * 24 * 1000 // 月固定开支 startOfHourSchedule(timeDefine.presetTime, dayTimeStamp, presetTimer.doSchedule) // 定时清除缓存步骤消息 setInterval(() =&gt; &#123; stepTimer.doSchedule() &#125;, timeDefine.clearStepMsgTime);&#125;const test = () =&gt; &#123; presetTimer.doSchedule()&#125;/** * 定义在每天的某个小时执行的任务 * @param &#123;Number&#125; targetHour 目标起始时间 * @param &#123;Number&#125; intervalTime 循环时间 * @param &#123;Function&#125; fun 要执行的函数 */const startOfHourSchedule = (targetHour, intervalTime, fun) =&gt; &#123; if (targetHour &lt; 0 || targetHour &gt; 23) &#123; return &#125; const date = new Date() const nowtimeStamp = date.getTime() const nowHour = date.getHours() date.setHours(nowHour + 1) date.setMinutes(0) date.setSeconds(0) date.setMilliseconds(0) const nextHourTimeStamp = date.getTime() const diffTime = nextHourTimeStamp - nowtimeStamp const hour = 60 * 60 * 1000 let time = 0 if (nowHour &lt; targetHour ) &#123; // 当前时间小于预计时间 time = targetHour - nowHour -1 &#125; else &#123; time = 24 - (nowHour - targetHour + 1) &#125; console.log('将于' + Math.ceil((diffTime + hour * time) / 1000 / 60) + '分钟后执行定时任务' + i++) // 开启24个settiemout 0-23 分别对应下n个整点时间 setTimeout(() =&gt; &#123; fun() setInterval(() =&gt; &#123; fun() &#125;, intervalTime); &#125;, diffTime + hour * time);&#125;module.exports = &#123; init&#125; 这样写了之后，我们在项目的app.js中调用这个文件的init方法即可。 然后对于具体的固定收支添加账单的逻辑就比较简单了，就不再放到上面了，有兴趣的可以到我的github上看源码。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（二）]]></title>
    <url>%2F2019%2F07%2F17%2Fwechat-account-02%2F</url>
    <content type="text"><![CDATA[上次微信公众号制作记账功能（一）把nodejs的环境搭好了，并且可以简单地回复用户地信息了，那么接下来就要正式实现我们地功能了。 为了方便大家查看，也方便大家自己部署到公众号上，我把代码放到github上了，有兴趣可以去看一下。 一、功能分发因为我的订阅号的权限十分有限，那么基本上就只能靠用户的输入来猜测命令了，打开/routes/wx.js，找到处理普通文字消息的代码，进行如下修改： 12345678910111213// 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 moneyManager.doQuery(json.xml).then(msg =&gt; &#123; if (!msg) &#123; tempBody.xml.Content = '你好,我在努力进步中哦...' &#125; else &#123; tempBody.xml.Content = msg &#125; resbody = jParser.parse(tempBody) res.send(resbody) &#125;) &#125; 1、链式调用模块首先我的需求是不止有记账这一种功能，可以想见，那么多命令，如果都在wx.js里判断，那以后光找功能就要找好久。 我的思路是，将命令划分为几个模块，然后每个模块有自己专门的命令分发方法，每个模块处理完之后，wx.js就只负责将处理的结果返回给用户。 那么怎么判断这个命令属于哪个模块呢？我的想法是利用Promise的链式调用，如果上一个模块没有返回值，就执行下一个模块的命令分发，直至匹配到一个模块。类似下面这种方式： 12345678910111213function modelA() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;function modelB() &#123; return new Promise(function(resolve, reject) &#123;&#125;&#125;;modelA().then((res) =&gt; &#123; if (!res) &#123; return modelB() &#125; else &#123; return '' &#125;&#125;) 目前只定义了一个模块，暂时看不出效果，不过后面我会定义一个默认模块，即若前面的模块都没有匹配到命令时，进入该模块返回一个默认的回复信息。 2、命令识别 人工智能离用户很近，但离开发者很远~ 首先，记账模块有三个子功能：记账、查询账单、统计，而且记账时我想让用户直接输入，因为输入就已经够麻烦了，不能再增加步骤了。 那么在分发的入口就先去匹配固定的命令，如果没有匹配到，再去匹配记账这个随机性很大的命令。而在匹配记账的过程中，我用的是比较笨的方法，定义一个用户可能会输入的数组，然后再去匹配。 下面放上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// /service/money.jsconst keywords = [ '吃饭', '购物', '工资', '日用', '交通', '零食', '运动', '娱乐', '通讯', '服饰', '住房', '居家', '社交', '旅行', '烟酒', '数码', '医疗', '书籍', '礼物', '快递', '水果', '蔬菜', '亲友', '彩票', '捐赠', '维修', '办公', '宠物', '学习', '汽车', '美容', '兼职', '理财', '礼金', '早餐', '午餐', '晚餐', '早饭', '午饭', '晚饭']const mt = [-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1]// 功能分发const doQuery = (payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 在此处比较数量是否一致，防止输入时出错 if (process.env.NODE_ENV === 'development') &#123; console.log('记账关键词与盈亏数量对比：', keywords.length, mt.length) &#125; if (payload.Content === '账单') &#123; queryBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else if (payload.Content === '统计') &#123; tongji(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; else &#123; // 记账 addBill(payload).then(msg =&gt; &#123; resolve(msg) &#125;) &#125; &#125;)&#125;// 记账const addBill = (&#123;FromUserName, CreateTime, Content, MsgId&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; let index = -1 keywords.some((item, idx) =&gt; &#123; if (Content.indexOf(item) &gt;= 0) &#123; index = idx return true &#125; &#125;) if (index &gt;= 0) &#123; const price = parseFloat(Content.replace(keywords[index], '')) if (!price) &#123; res('错误提示：未输入金额或金额格式错误\n所属模块：[记账]') &#125; else &#123; const tempTxt = mt[index] &gt; 0 ? '收入' : '支出' retMsg = `记录成功！\n$&#123;keywords[index]&#125; $&#123;tempTxt&#125; $&#123;price&#125;元` res(retMsg) &#125; &#125; else &#123; res('') &#125; &#125;)&#125;// 查询账单const queryBill = (&#123;FromUserName, CreateTime&#125;) =&gt; &#123; return new Promise((res, rej) =&gt; &#123; var str = '您的账单如下:\n' res(str) &#125;) &#125;)&#125;// 统计const tongji = () =&gt; &#123;&#125;module.exports = &#123; doQuery&#125; 我将模块都放在service目录，以便统一管理。上面的代码Promise用得总感觉有点别扭，但还是可以正常运行的，等哪天开窍了估计就能写出更优雅的代码了。 二、数据存储记账记账，如果不存下来，那还叫什么记账？ 1、简单介绍nodejs在数据存储方面的选择其实有很多种，但限于我的服务器很菜，我只能选择基于文件系统的数据库了，那就排除掉MySql、Redis。然后我听人推荐LevelDb，好家伙，感觉比Redis难用多了，我就想简单地放个对象数组，放了大半天都失败了，还读取不到！然后又把目光放到Sqlite3上面，又是一个好家伙，我还要在代码中定义数据结构，这还是我印象中地js吗？ 就在我彷徨不所知时，一道闪电击中了我的脑袋，nedb!赶忙在github上搜索，竟然搜到了这个数据库，然后赶紧试试能不能用，好不好用。用过之后，我只有一个感觉，丝滑~ 我就稍微介绍一下它吧（太丝滑了，必须得多说几句啊），nedb是mongoDb的一个子集，mongoDb相信大家会有所耳闻，而子集，就是将mongoDb的常用操作抽取出来了，所以用着是真的顺手。啥也不说了，先放链接： https://github.com/louischatriot/nedb 这是我生成的数据库文件，没错，只有一个文件，文件内容肉眼可读！一个字，强啊。 2、应用在nedb中，一个表就是一个文件（个人肤浅见解），因此管理表的任务就交给我们了。 我的做法是专门用一个文件/service/db.js去管理数据库信息: 12345678var Datastore = require('nedb')// 生成nedb的实例并自动打开数据库var moneyDb = new Datastore(&#123; filename: 'moneyLog.db', autoload: true &#125;)// 这里我考虑到项目中不止会用到一张表，就用这种方式导出多个nedb的操作对象module.exports = &#123; moneyDb&#125; 然后在/service/money.js中的用法就是： 123456789101112131415161718192021222324// 构造账单记录const bill = &#123; msgId: MsgId, type: keywords[index], yk: mt[index], price: price, openid: FromUserName, recordTime: CreateTime&#125;// 没错，就这么简单就插入了db.moneyDb.insert(bill)// ...var str = '您的账单如下:\n'// 查询也很简单，还可以排序，具体的可以看github上的文档db.moneyDb.find(&#123;openid: FromUserName&#125;).sort(&#123;recordTime: -1&#125;).exec((err, docs) =&gt; &#123; docs.forEach(item =&gt; &#123; const d = dateUtil.getNowSimpleFormatDate(new Date(CreateTime * 1000)) const s = `[$&#123;d&#125;] $&#123;item.type&#125; $&#123;item.price&#125;元\n` str += s&#125;)res(str)&#125;) 做到这一步之后，就可以运行查看效果了。 可以看到，这里我专门取消关注后再新增的记录，一样可以获取到以前的记录。 当然，这个功能还有许多地方要完善，比如支持查询啦，支持翻页啦，这些就放到下次再讲吧。 三、自适应环境这个标题实在想不到既简短又直击要害的了… 通常情况下，我们的开发环境和生产环境的配置信息是有所不同的，那我们每次切换环境都要重新手动修改配置文件吗？ 这当然不行。 以前这种区分开发环境和生产环境的功能也用过，不过都是别人写好的模板，这次总算自己实现了一下。 原理很简单，我们的系统都是可以设置环境变量的，而我们平常运行项目执行的yarn start或者npm start其实都是执行的package.json中配置的scripts: {&quot;start&quot;: &quot;node xxxx.js&quot;}这种命令。那我们就可以在执行这个命令之前先将系统的环境变量设为开发环境或生产环境，然后程序里读取当前是开发环境还是生产环境，然后加载不同的配置文件就可以了。 首先，了解一下设置环境变量的方式： 1234# windows系统set NODE_ENV=development# Linux/Mac系统export NODE_ENV=development 不同操作系统的命令不一样，这确实给我造成了不小的困扰，但也只能在不同的系统上再手动改一下了。 然后修改packages.json： 12345// 开发环境是windows，因此先设置为windows的命令"scripts": &#123; "dev": "set NODE_ENV=development&amp;&amp; nodemon ./bin/www", "prod": "set NODE_ENV=production&amp;&amp; nodemon ./bin/www" &#125;, 上面用到了&amp;&amp;用于在同一行内区分两条命令，同时要注意的是，&amp;&amp;前面不能用空格分开！，这导致我一直无法区分开发环境和生产环境。 这样修改之后，在js代码中，就可以通过以下代码进行判断： 1if (process.env.NODE_ENV === 'development')&#123;&#125; 这样设置完成基本上就可以了，但因为我想把代码放到github上让大家参考，又不能把自己的密钥之类的放在上面，那么我就还需要想点褶子。 首先，项目中要将开发环境和生产环境的配置文件分开，同时要将私密信息单独创建一个文件，还要有一个文件专门放不会变的配置信息。因此，我的config文件夹就变成了这个样子： 其中*.self.js是我配置私密信息的地方，然后在dev.js中获取，最后在index.js中判断环境后获取对应的配置信息。然后，我再将*.self.js的文件设置为忽略上传就可以了。不过这样的话我又要去写README.md了。。。 下面附上index.js中区分环境的代码： 12345678910const devConfig = require('./dev')const prodConfig = require('./prod')// 区分开发环境和生产环境const env = process.env.NODE_ENV || 'development'var isDev = env === 'development'// 每次启动时会打印当前运行环境，更好的提醒使用者console.log('当前运行环境：',env)const appid = isDev ? devConfig.appid : prodConfig.appid 总结在做这个记账功能的时候，数据库的选择真的是卡了我好长时间，还好有那一道闪电~ 最后，希望大家可以关注一下我的公众号，体验一下微信记账的感觉~]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号制作记账功能（一）]]></title>
    <url>%2F2019%2F07%2F16%2Fwechat-account-01%2F</url>
    <content type="text"><![CDATA[一直想写一个记账软件，但界面的设计真让我头大。这不，刚买了个服务器，那用这个当后台存储，微信公众号菜单作为界面交互，练个手？ 我的服务器只有512M内存，10G硬盘，跑Java就别想了。刚刚看自己的SpringBoot应用跑在自己电脑上就占了479M内存，这还没说Mysql呢，服务器还挂着SSR，没办法，不能用Java来开发了。 从网上查找Java、Python、nodejs、php的性能比较，都说nodejs性能最好，那就玩nodejs喽（当然我在python上纠结过，不过nodejs一是比较熟悉，而是自己想实现的聊天机器人可以通过API调用来实现，也就是python能做的nodejs都有替代方案，性能又好，那必须选它了） 一、环境搭建1、安装express这里就参考Express官方文档一步步操作的。 不过官方文档稍微有点啰嗦，说了前一步，结果后面告诉你前面的方法太Low了。所以这里我就把关键部分再描述一遍。 全局安装Express脚手架： 1$ yarn global add express-generator 创建项目： 1$ express --view=pug myapp 如果不输入项目名[myapp]，就会在当前目录生成各种文件。 如果不输入–view=pug，控制台会报错jade模板不能用之类的事，我怂，我输入。 进入项目，安装依赖并运行： 123$ cd myapp$ yarn$ yarn start 2、控制台输出端口信息这时控制台是很干巴巴的，对于就喜欢看控制台不停输出信息的Java开发者来说，难受吖。 打开/bin/www，找到末尾的onListening方法，这样进行改动： 12345function onListening() &#123; // ... debug('Listening on ' + bind); console.log('Listening on ' + bind)&#125; 然后控制台就会输出Listening on port 3000了，舒服了舒服了。 3、代码自动刷新习惯了vuejs的自动刷新，每每改完文件还要Ctrl + C、Y、⬆是真的痛苦。还好我有~ nodemon 首先全局安装nodemon： 1$ yarn global add nodemon 打开package.json，修改scripts： 1"start": "nodemon ./bin/www" 依旧是原来的配方，yarn start启动项目，舒服了舒服了。 二、与微信服务器“配对”申请微信公众号之后，在开发者工具中找到公众平台测试账号，填写接口配置信息。 当然现在点击保存肯定是提示配置失败的，下面我们开始配置自己的Express服务器来正确响应微信服务器的消息。 在/routes/目录下新建wx.js文件，直接把user.js的内容复制过来。打开app.js，仿照user.js导入路由的方式： 12var wxRouter = require('./routes/wx')app.use('/cqm/wx', wxRouter) 然后在测试号的页面再次点击保存，这次不是为了配对成功，而是查看接口会传来什么参数，然后我们需要验证这是微信服务器发来的消息。 此时需要安装一个模块用来加密信息： 1$ yarn add jssha --dev 然后就是根据传来的参数验证信息，成功后把echostr字段返回给微信服务器。 12345678910111213141516171819202122232425// 微信服务器认证router.get('/', function(req, res, next) &#123; // 1 获取微信服务器请求参数 var signature = req.query.signature // 加密签名 var timestamp = req.query.timestamp // 时间戳 var nonce = req.query.nonce // 随机数 var echostr = req.query.echostr // 随机字符串 console.log(`接收到微信服务器认证请求`) // 2 将token timestamp nonce 按字典序排序 var array = [config.token, timestamp, nonce] array.sort() // 3 将参数加密 var tempStr = array.join('') var shaObj = new jsSHA('SHA-1', 'TEXT') shaObj.update(tempStr) var scyptoStr = shaObj.getHash('HEX') // 4 将加密后的字符串与signature对比，相同则表示验证成功 if (signature === scyptoStr) &#123; console.log('验证成功') res.send(echostr) &#125; else &#123; console.log('验证失败') res.send('验证失败') &#125;&#125;); 保存后在微信测试号里再次保存配置信息，就可以保存成功了。 我在测试时用到了一个公司的反向代理工具，把自己电脑映射到服务器的指定网址了。其实原理是差不多的，你只要有一台自己的服务器，在上面配置nginx反向代理，映射到你本机，就可以实现开发环境与微信服务器联调了。 三、响应用户发来的消息微信服务器会把用户发送的消息以post方式发送到刚刚验证的接口，同样的，我们需要正确回复微信服务器。 1234567891011121314// 微信服务器消息接收router.post('/', (req, res, next) =&gt; &#123; var signature = req.query.signature var timestamp = req.query.timestamp var nonce = req.query.nonce var openid = req.query.openid // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`)&#125;) 然后手机关注自己的测试号并随便发送一个消息，就可以看到自己的回复了： 还是很神奇的，不过到这一步只是简单实现了回复消息，实际上我们没有识别用户的输入，也没有做其他复杂的机制，比如5秒内无法回复时要先返回success告知微信服务器我收到消息了，还要应对微信服务器的3次重试机制。 下面就先实现识别用户发送消息的功能： 在nodejs中，接收post请求参数的方式和Java的不一样，Java直接就可以获取了，而nodejs还要等待数据传输完毕。因此我们就需要先监听数据传输事件，并将数据保存到一个buffer中，然后监听接收完成的事件，接着才是处理数据及返回消息的步骤： 12345678910111213141516 var buffer = []// 监听data事件 用于接收数据 req.on('data', data =&gt; &#123; buffer.push(data) &#125;) // 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; console.log(Buffer.concat(buffer).toString('utf-8')) // 需要回复success微信才会认为服务器已经收到消息 var to = `&lt;ToUserName&gt;$&#123;openid&#125;&lt;/ToUserName&gt;` var from = `&lt;FromUserName&gt;$&#123;config.userName&#125;&lt;/FromUserName&gt;` var time = `&lt;CreateTime&gt;$&#123;timestamp&#125;&lt;/CreateTime&gt;` var type = `&lt;MsgType&gt;text&lt;/MsgType&gt;` var msg = `&lt;Content&gt;你好,我在努力进步中哦...&lt;/Content&gt;` res.send(`&lt;xml&gt;$&#123;to&#125;$&#123;from&#125;$&#123;time&#125;$&#123;type&#125;$&#123;msg&#125;&lt;/xml&gt;`) &#125;) 用惯了Java的我，发现不能直接获取post请求参数之后，我还傻傻地去找转换工具，结果看到了一个body-parser，用了之后发现没效果。算了算了，入乡随俗。 这样修改之后，就可以获取到用户发来的消息了： 下面就是解析信息了（看到请求消息才明白官方文档的![CDATA[]]是不能省略的，但竟然识别出了我的回复，强吖） 安装fast-xml-parser： 1$ yarn add fast-xml-parser 解析xml数据： 12345var xmlParser = require('fast-xml-parser')var xml = Buffer.concat(buffer).toString('utf-8')console.log(xml)var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml))console.log(json) 然后，我们熟悉的json就又回来啦： 四、自定义菜单被动回复我们现在可以做到了，下面就是要主动向微信服务器发送消息告诉它我们要设置菜单项！ 1、获取access_token与微信服务器的很多交互都需要用到access_token的，而access_token有7200秒（2小时）的有效期，那我们需要做的，就是在项目启动后获取一次access_token，并且启动一个定时器，每隔7000秒重新获取一次。 因为习惯了vue.js的开发模式，我这里在项目根目录下新建了/api/wx.js文件，专门负责发送微信请求。在请求库的选择上，因为我们现在是服务端，不可能只请求一个域名，那么用axios设置baseUrl的方式就不是特别合适，就直接用request库来发送请求就好了，每次请求都定义一下url，也没有特别麻烦，而且我看很多人都这么用，那应该不会错了。 安装request和querystring： 12$ yarn add request$ yarn add querystring 其中querystring是将json数据转换为url请求参数的库 然后开始编写请求方法： 1234567891011121314151617181920212223242526var config = require('../config/index')var qs = require('querystring')var request = require('request')// 获取AccessTokenconst getAccessToken = () =&gt; &#123; const params = &#123; 'grant_type': 'client_credential', 'appid': config.appid, 'secret': config.appsecret &#125; const url = `$&#123;config.wxUrl&#125;cgi-bin/token?$&#123;qs.stringify(params)&#125;` // console.log('getAccessToken请求地址为', url) return new Promise((resolve, reject) =&gt; &#123; request(&#123; method: 'GET', url: url &#125;, (err, res, body) =&gt; &#123; if (res) &#123; resolve(JSON.parse(body)) &#125;else&#123; reject(err) &#125; &#125;) &#125;)&#125; 打开/bin/www： 1234567891011121314151617var wxAPI = require('../api/wx')function onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000);&#125; 然后重新运行项目，就会在控制台打印出我们获取到的token，这里将access_token保存到了global全局对象中，方便其他地方使用。 nodemon好像不会监听www文件的修改，所以需要我们重新启动服务。 2、配置自定义菜单有了access_token，我们就可以放心地向微信服务器发送请求了。但在此之前，我们还没有定义自己的菜单呢。我这里将菜单保存为json格式，同时也是熟悉一下文件操作： /config/wxmenus.json 12345678910111213141516171819202122232425262728293031323334&#123; "button": [ &#123; "name": "记账", "sub_button": [ &#123; "type": "click", "name": "收入", "key": "add_money" &#125;, &#123; "type": "click", "name": "支出", "key": "sub_money" &#125;, &#123; "type": "click", "name": "账单", "key": "bill" &#125;, &#123; "type": "click", "name": "预算", "key": "wish" &#125; ] &#125;, &#123; "type": "click", "name": "待办", "key": "todo_list" &#125; ]&#125; 因为我要做记账的功能，所以就预先把菜单定义好，后面也省得再去调整了。 首先尝试一下能否正确读取出json文件： /api/wx.js 12345678910111213141516var fs = require('fs')// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 var m = JSON.parse(data.toString()) resolve(m) &#125; &#125;) &#125;)&#125; 注意这里的文件路径是基于项目路径而不是wx.js当前路径。 然后同样在www中的onListening添加调用： 123456// 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) 重启服务就会在控制台看到我们要的结果： 下面继续修改wx.js，将我们配置的菜单发送给微信服务器。 1234567891011121314151617181920212223242526// 设置自定义菜单const setMenu = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 读取json文件 fs.readFile('./config/wxmenus.json', (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 得到配置的菜单信息 const menuData = data.toString() const url = `$&#123;config.wxUrl&#125;cgi-bin/menu/create?access_token=$&#123;global.access_token&#125;` request(&#123; method: 'POST', url: url, form: menuData &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(JSON.parse(body)) &#125; &#125;) &#125; &#125;) &#125;)&#125; 改完这个之后还不够，因为这里用到了access_token，我们必须保证在发送菜单的这个请求时我们已经获取到了access_token，那么我们就要修改www文件： 1234567891011121314151617181920212223242526var isInit = falsefunction onListening() &#123; // ... var getToken = () =&gt; &#123; wxAPI.getAccessToken().then(data =&gt; &#123; global.access_token = data.access_token console.log(global.access_token) if (!isInit) &#123; // 设置微信菜单 wxAPI.setMenu().then(data =&gt; &#123; console.log(data) &#125;).catch(error =&gt; &#123; console.error(error) &#125;) isInit = true &#125; &#125;).catch(error =&gt; &#123; console.log(error) &#125;) &#125; getToken() // 每隔7000秒重新获取一次access_token setInterval(() =&gt; &#123; getToken() &#125;, 7000 * 1000)&#125; 这里就是通过一个标志位来判断获取access_token后是否还需要发送设置菜单的请求。然后取消关注测试号，再重新关注一下： 可以看到我们的菜单已经设置生效了。在这个过程中我还注意到控制台还接收到了用户关注和取消关注事件的请求，这表明这个post接口不只是用来接收消息的，应该还有其他用处。 3、接收菜单点击事件到这一步就要参考微信官方文档给的事件类型了，然后在/routes/wx.js中根据不同类型做出不同回应即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 监听end事件，用于处理接收完成的数据 req.on('end', () =&gt; &#123; var xml = Buffer.concat(buffer).toString('utf-8') var json = xmlParser.convertToJson(xmlParser.getTraversalObj(xml)) console.log(json) // 定义返回消息 var resbody = 'success' var tempBody = &#123; xml: &#123; ToUserName: json.xml.FromUserName, FromUserName: json.xml.ToUserName, CreateTime: timestamp, MsgType: 'text' &#125; &#125; var jParser = new xmlParser.j2xParser() // 判断消息类型 if (json.xml.MsgType === 'text') &#123; // 普通文字消息 tempBody.xml.Content = '你好,我在努力进步中哦...' resbody = jParser.parse(tempBody) &#125; else if (json.xml.MsgType === 'event') &#123; // 事件类型 一共有六种事件1 关注/取消关注事件 2 扫描带参数二维码事件 3 上报地理位置事件 4 自定义菜单事件 5 点击菜单拉取消息时的事件推送 6 点击菜单跳转链接时的事件推送 if (json.xml.Event === 'CLICK') &#123; // 自定义菜单事件 tempBody.xml.Content = `您点击了$&#123;json.xml.EventKey&#125;` resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'subscribe') &#123; // 关注事件 tempBody.xml.Content = '欢迎关注' resbody = jParser.parse(tempBody) &#125; else if (json.xml.Event === 'unsubscribe') &#123; // 取消关注事件 该事件不能给用户发送消息 resbody = '' &#125; else if (json.xml.Event === 'LOCATION') &#123; // 上报地理位置事件 暂时不考虑 resbody = '' &#125; else &#123; // 其他事件有点复杂，先不做处理 &#125; &#125; res.send(resbody) &#125;) 然后取消关注测试号再重新关注，将刚刚的几种事件类型试一下，看看会不会做出正确的响应即可。 五、部署到正式的公众号我的服务器是CentOS，并且是刚刚创建的，一片空白，那现在就需要安装nodejs环境和ftp服务了。 以前自己在Linux下安装过ftp，不过失败了。但这次！看了leoxuan的CentOS7 FTP安装与配置后，我成功了！ 大家在按着这个教程来的时候用户名一定要弄对，上面截图中的一个错误就是我直接复制文章中的代码忽略了用户名才出错的。 传输文件时我这里一直无法传输，按文章中说的关闭SeLinux也不行，更改权限775不起作用，最后索性改为777才可以成功上传。 下面，在app.js中修改我们的代码，不再监听/cqm/wx了，这次翻身做主人，直接监听/wx！ 然后打包（压缩）项目，上传到服务器。 下面需要在服务器安装nodejs，这里我是参照CentOS7.5安装nodejs进行安装的。我选择的是第二种方法，毕竟以后全局安装插件就可以省点事了。 不过编译真的好慢啊，我写完这行字的时候它还没有编译好。。。 上面的安装对我来说完全不起作用，又参考了一篇文章在CentOS 7上安装Node.js的4种方法（包含npm）,用其中的第四种方法，终于是成功了，下面我把命令粘贴一下，方便以后使用。 123456curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bashsource ~/.bash_profilenvm list-remotenvm install v10.16.0node -vnpm 然后再安装我们需要的各种依赖，就可以使用yarn start启动项目了。 但我们的服务是放在3000端口的，我们需要配置nginx服务器的反向代理。 1234567server &#123; listen 80; server_name aqzscn.com; location / &#123; proxy_pass http://127.0.0.1:3000/wx; &#125;&#125; 经过一番配置，运行，然后在微信公众号上配置自己的服务器信息（不要忘记修改Appid和Secret为公众号的），然后你就会发现，还有一大堆问题要解决。 其中ip不在白名单的问题好解决，直接在公众号上设置就好了，但下面的问题是真的没办法解决。 没有权限。。好忧桑。。兴奋了大半天，没办法搞下去吖 服务号又只能企业来做，那我只好等有钱了注册个公司搞这个了。 那最后的最后，就试一下发送消息是否成功把。 看样子是可以的，那还算是有点安慰，不枉这么长时间的辛苦。 看着这少得可怜的权限，以后怕是只能玩聊天机器人了。 总的来说，下面就要想点奇招才能完成自己的记账功能了。那么各位看官，请看下回分解。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（三）]]></title>
    <url>%2F2019%2F07%2F15%2Flearn-hexo-03%2F</url>
    <content type="text"><![CDATA[这里是对Hexo的第三次探究主要就是将博客的内容丰富了一下。 有兴趣的小伙伴可以看看前面两篇文章： Hexo搭建Github Pages个人博客（一） Hexo搭建Github Pages个人博客（二） 下面进入正文。 一、设置侧边栏社交链接打开主题配置，搜索social，下面已经用注释帮我们写好了很多链接的模板，直接套上自己的就可以了。下面放上我的配置： 1234567social: GitHub: https://github.com/godbobo || github E-Mail: mailto:bobobiubiubiubiu@gmail.com || envelope Weibo: https://weibo.com/p/1005056965815024/info || weibo Twitter: https://github.com/godbobo || twitter Zhihu: https://www.zhihu.com/people/zheng-bo-33-3/activities || university Instagram: https://www.instagram.com/bobobiubiubiubiu/ || instagram 唯一需要注意的就是知乎的图标font awesome上面没有，我找了个university替代，反正有个叫知乎大学的鬼东西（用都没用过） 下面是实现效果： 二、标签前面用图标表示默认情况下标签前面是一个#，换成标签图标那得有多高大上。 这个操作并不难，以前的版本可能还需要改模板代码，现在直接在主题配置文件改配置就行了！ 搜索tag-icon，将其改为： 1tag_icon: true 可以看到，标签前面已经有小图标了。 三、头像的折腾主题配置文件中有个avatar.ratated的属性，设置为true后，鼠标移动到头像上就会旋转360度。 想要更加高级的动画的话，可以用animate.css。首先在bootcdn找到它的link标签： 1&lt;link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet"&gt; 然后将其添加到\themes\next\layout\_partials\head\head.swig文件的末尾，在\themes\next\source\css\_common\components\sidebar\sidebar-author.styl中搜索avatar.rotated，可以发现刚刚旋转360度的代码实现，将其注释掉并换为animate.css中的动画即可。 12345678910111213if hexo-config('avatar.rotated') &#123; .site-author-image:hover &#123; -webkit-animation: bounceIn 1s; animation: bounceIn 1s; &#125; /*.site-author-image &#123; transition: transform 1.0s ease-out; &#125; .site-author-image:hover &#123; transform: rotateZ(360deg); &#125;*/&#125; 个人感觉这个折腾的意义不大，所以我最后还是没有给头像加动画，静静地待在那里不好么~ 若要尝试动画效果，可以去animate.css官网查看。 四、站点图标在主题配置文件中搜索favicon即可配置，图片资源放在主题目录下的source中，具体我就不尝试了，因为还没有找到一个好的图标，默认的就挺好看的。 五、鼠标点击特效鼠标在点击页面空白处的时候显示向上移动的心，想不想要想不想要？ 这个js文件比较好找，我自己也找了一个版本，效果还OK，就直接放到附录的鼠标点击特效文件里了，有需要的可以直接复制。 将heart.js文件放在/themes/next/source/js/目录中，找到/themes/next/layout/_layout.swig，搜索vendors.swig，在这一行的上面引入刚刚创建的js文件： 1&lt;script src="/js/heart.js"&gt;&lt;/script&gt; 放到文件末尾似乎和Next有冲突，放在这个位置我这里是没有问题的。 六、评论系统文章如果没有评论岂不是失去了灵魂？ 经过一天时间，leanCloud的实名认证终于下来了。进入控制台后，点击应用-创建应用，输入名字即可创建应用。 然后回到主题配置中，搜索valine，开启并填写自己的appid和appkey，最好把语言也修改一下，邮件通知我觉得就没有必要了，万一有一天我的博客很火把我吵得生活不能自理怎么办？ 重新运行即可看到效果： 当然，为了安全起见，还是要设置安全域名的： 七、留言板评论系统都有了，那留言板还不是手到擒来？ 在站点根目录键入命令： 1$ hexo new page message-board 打开/source/message-board/index.md，修改标题名： 1234---title: 留言板date: 2019-07-15 17:38:28--- 主题配置文件搜索menu，在下面添加一行代码： 12menu: 留言板: /message-board/ || inbox 我这里懒得去弄多语言了，直接把汉字作为key 重新运行，噔噔噔噔~ 八、浏览量功能知道你看过我，我会很开心的~ 打开leanCloud，依次点击应用 - 存储 - 创建Class，然后创建一个名为Couter的Class，并设置权限为无限制。 主题配置中，搜索valine，开启visitor功能即可。 这样只是开启了文章的浏览量统计功能，这当然不够，我要知道整个网站的访问量！ 主题配置中搜索busuanzi_count,设置为true即可。 怎么样，有没有吓一跳，这么多访客量！好吧，反正我是吓一跳，后面才明白我什么都没配它就给我显示了，那它应该记的是整个网址的访问量，而localhost？每天有多少人访问呢？ 哈哈哈哈哈哈哈 九、修改文章内链接样式蓝色链接看多了，黑色链接就不怎么习惯了。 打开themes\next\source\css\_common\components\post\post.styl，新增如下代码： 1234567891011/*修改链接样式*/.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 然后，就可以习惯了~ 十、显示公众号订阅我也是个想要订阅的人。 在微信公众平台的公众号设置中下载自己的二维码 然后把它放到站点的/source/uploads目录下，并重命名为wechat-qcode.jpg 主题配置中搜索wechat_subscriber，开启该功能并取消注释即可。 十一、打赏功能公众号都有了，不要点打赏怎么行？ 主题配置中搜索reward_settings,把下面的内容开启就行了，付款的图片当然也是需要的。 看到下面的比特币，好想把它开启，可是我并没有。。。 微信收款码获取方式： 聊天列表 - 收付款 - 二维码收款 - 保存收款码 我不想设置金额，我想要大大的惊喜。。（我想的可真多。。） 支付宝就比较简单，首页点击收钱就可以看到保存图片的按钮了。 实现效果如下： 千万不要开启reward_settings.animation！！！这是我的忠告~ 十二、腾讯公益404页面既然收了打赏，那就做点公益把 在/themes/next/source/目录下新建404页面，内容复制即可： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 不过奇怪的是我故意输错网址，却是一个空白的错误界面，非要我输入http://localhost:4000/404.html才会显示。不知道是出什么问题了。 附录1、鼠标点击特效文件heart.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 从jianhuax.com下载的(function(window,document,undefined)&#123;var hearts = [];window.requestAnimationFrame = (function()&#123;return window.requestAnimationFrame ||window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame ||window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function (callback)&#123;setTimeout(callback,1000/60);&#125;&#125;)();init();function init()&#123;css(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;");attachEvent();gameloop();&#125;function gameloop()&#123;for(var i=0;i&lt;hearts.length;i++)&#123;if(hearts[i].alpha &lt;=0)&#123;document.body.removeChild(hearts[i].el);hearts.splice(i,1);continue;&#125;hearts[i].y--;hearts[i].scale += 0.004;hearts[i].alpha -= 0.013;hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color;&#125;requestAnimationFrame(gameloop);&#125;function attachEvent()&#123;var old = typeof window.onclick==="function" &amp;&amp; window.onclick;window.onclick = function(event)&#123;old &amp;&amp; old();createHeart(event);&#125;&#125;function createHeart(event)&#123;var d = document.createElement("div");d.className = "heart";hearts.push(&#123;el : d,x : event.clientX - 5,y : event.clientY - 5,scale : 1,alpha : 1,color : randomColor()&#125;);document.body.appendChild(d);&#125;function css(css)&#123;var style = document.createElement("style");style.type="text/css";try&#123;style.appendChild(document.createTextNode(css));&#125;catch(ex)&#123;style.styleSheet.cssText = css;&#125;document.getElementsByTagName('head')[0].appendChild(style);&#125;function randomColor()&#123;return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")";&#125;&#125;)(window,document); 总结这次修改的大部分还都是可以直接配置的，但还没有结束，这不是我的博客的最终样子。它还需要做最后的蜕变！ 下一篇文章应该就是大量的自定义样式了，敬请期待。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（二）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-02%2F</url>
    <content type="text"><![CDATA[有点无聊，有点焦虑。 今天下午刚搞完第一波Hexo的部署，晚上又闲的没事干，那就继续捣鼓这个博客吧。 这是第二篇有关Hexo的文章，没有看过第一篇的可以去瞅瞅： Hexo搭建Github Pages个人博客（一） 一、背景动画相信大家在浏览网站时肯定见过网页背景随鼠标移动而变化的特效，以前以为很高大上，原来就是引一个js库的事。 这个功能仅适用于next主题，其他主题没有实验过。 打开/themes/next/_config.yml，搜索Animation Settings，第一个默认是开启的，看着可配置项有fadeIn之类的，猜想应该就是首页加载时各个部件的渐隐效果，那就不去动它了。 下面第二个叫pace的，看注释应该是进度条动画，那我觉得聊胜于无，开启就是了。下面就以这个库为例，讲一下怎么开启这个动画效果。 首先当然是要把pace.enable设置为true，单单这样是不够的，next主题并没有包含这个插件。如果就这样去运行，页面不会发生任何变化，而且控制台还会报404错误。 因此下一步就是去下载这个插件，next主题很贴心地把插件的地址放在了注释里面： 下载之后将其解压到/themes/next/sources/lib下面，然后将文件夹重命名为pace。 其他插件的导入方式类似，文件夹的名称要和配置文件中的名称保持一致。 导入成功之后就可以运行查看效果了。默认的minimal是浏览器顶部的一个蓝色进度条动画（页面加载时显示，普通情况下一条黑边）。 为了方便大家对比，也是解决这个无聊的周末夜晚，我一个一个把这些效果实验一下，供大家参考： 1、进度条动画主题描述 进度条下面的就都是背景动画了，官方文档说不能同时开启两个，但我试了一下，可以呀，只是不太好看而已~ 我也把所有的背景动画的特效试了一下，大家可以看截图选择自己看着舒服的。 2、背景动画特效展示 注意：下载的插件要把目录中的.github目录删掉，否则提交到github之后会找不到插件的路径。 二、百度统计详见https://theme-next.iissnan.com/third-party-services.html#analytics-baidu 配置成功后可以将项目发布在github上，然后检查是否安装正确： 三、谷歌站点收录详见https://theme-next.iissnan.com/third-party-services.html#google-webmaster-tools 刚刚配置的时候忘了截图了，现在已经找不到那个页面了。 不过只要注意在输入网址之后展开第一种验证方式就可以找到我们要的代码了。 四、本地搜索功能用第三方搜索还要注册还要收费，我只需要一个简单的搜索哦~ 详见https://theme-next.iissnan.com/third-party-services.html#local-search 搭建完成的效果也还OK 五、显示文章基本信息就是这种效果： 打开_config.yml配置站点： 12345symbols_count_time: symbols: true # 文章字数 time: true # 阅读时长 total_symbols: true # 所有文章总字数 total_time: true # 所有文章阅读中时长 打开/themes/next/_config.yml配置主题： 123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 wpm: 275 这样我们只是配置好了，但是插件还没有安装，下面就安装插件（网上看的一篇文章说next主题自带该插件，我信以为真，结果死活不显示统计数量，也不报错，还专门去github上下载该插件，结果最后才发现是要用npm安装的。。。） 1$ yarn add hexo-symbols-count-time 然后重新运行就可以了，底部也会出现整个站点的统计字数。 六、滚动时显示文章进度在主题配置中搜索back2top，然后你懂的~ 123456back2top: enable: true # 在侧边栏显示该控件 sidebar: true # 显示阅读进度 scrollpercent: true 然后效果如下： 在点击这个控件后就会返回顶部。 虽然说放在侧边栏与潜意识里的返回顶部按钮不同，且用百分比来装饰，让人误以为它只是用来显示而不能点击的。但胜在能与周围融为一体呀，我不管，我就要这么设置！ 七、生成网站地图第三步已经生成了谷歌的站点地图，这里的设置主要是针对百度的。 安装sitemap插件： 12$ yarn add hexo-generator-sitemap$ yarn add hexo-generator-baidu-sitemap 然后将站点配置文件中的url改为自己的github地址即可。 重新运行，从地址栏输入/baidusitemap.xml查看有没有生成。 似乎百度不能抓取github.io下的内容，那搞它有什么用，不搞了不搞了。 八、附录1、进度条动画主题描述 theme 效果描述 big-counter 页面右上角显示加载百分比（数字） bounce 页面右上角显示一个跳动的小球，逐渐远去并消失 barber-shop 整个页面都被进度条占满。。。 center-atom 页面中间显示一个小花，花朵中间显示加载百分比 center-circle 页面中间显示有百分比的圆，有一个翻转消失的动画 center-radar 页面中间一个雷达旋转的动画 center-simple 顾名思义，特别简单，页面中间一个进度条 corner-indicator 右上角一个切角，里面是转圈的线条 fill-left 从左到右填充页面，与barber-shop的区别是不会遮挡页面元素。（十分不推荐选这个） flat-top 页面上方显示一个较宽的进度条 flash 页面上方显示较细的进度条，同时右上角有个加载状态的圆。（整体感觉不错，我可能会选它） loading-bar 同样是页面中间一个进度条。。 mac-osx 页面产生波浪，顶部有进度条。。（不是太好看呀，感觉侮辱了macOs呀） material 页面中间一个透明的圆，里面是百分比。（挺清爽的感觉，还可以） minimal 页面上方显示一个很细的进度条 这些主题尝试下来，有一个共同的特点，在页面超过一屏的情况下，顶部会有一个黑色的进度条区域（不管这里会不会显示进度条），所以建议选择带有顶部进度条的主题。 2、背景动画特效展示canvas_nest: 就是红框中的那些线条，可以跟随鼠标移动。 three.three_waves: three共包含三种特效，因此配置文件中有两个开关都要打开才行。 效果挺震撼的，在页面空白区域比较多的时候看着特别爽。 three.canvas_lines: three.canvas_sphere: 这个动画动的幅度比较小，一般只能在页面切换时才能看到，平时就被文章给盖住了。 canvas_ribbon： 这个不会动，只会在鼠标点击时切换背景。 总的来说，这些动画都挺好看的，但是我就觉得有一种哗众取宠的感觉。我的注意力应该放在文字本身，你旁边动来动去的背景是想干啥？ 所以最终我选择了奢华低调有内涵的three.canvas_sphere 最后，还是想说一下，本来想搞一个评论系统的，结果leanCloud刚实名认证不能创建应用，其他的要么被墙要么收费，真是难为死我了。 说不得还得来个Hexo系列文章三呢。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github Pages个人博客（一）]]></title>
    <url>%2F2019%2F07%2F14%2Flearn-hexo-01%2F</url>
    <content type="text"><![CDATA[以前也了解过Hexo，但因为各种操作都需要敲命令，我这么懒，就是不想敲命令~所以就没怎么玩过这个。这些天无意间了解到有个Hexo的客户端，觉得可以试试了。 搭建完成之后文章列表只有一篇HelloWorld，不能忍不能忍，于是诞生了这篇文章。。。。 一、开启Github Pages在Github中创建一个新的仓库，仓库名字为：[你的用户名].github.io,例如我的用户名为godbobo，那么填写的名称就是godbobo.github.io 其他什么都不用填，点击创建。然后打开该项目的Settings: 在Github Pages这个栏目下点击Choose Theme。（我这个是已经创建好的，界面和没有创建过的是不一样的） 然后会跳转到选择主题的界面，直接默认第一个就好，反正后面还要换成Hexo的，选择之后在新的页面点击commit提交更改，一个崭新的Github Pages就建立好了，并且可以直接通过刚才的项目名进行访问。 一个账号只能有一个Github Pages可以通过这种方式访问。 到这一步，Github Pages就算是配置好了，下面就要开始激动人心的Hexo配置了。 二、安装Hexo首先全局安装Hexo脚手架： 1$ npm install hexo-cli -g 不知道为什么，我用yarn安装之后命令行没有hexo这个命令，万般无奈之下，我还是用了npm来安装。。。 用脚手架初始化博客目录： 123$ hexo init godbobo.github.io$ cd godbobo.github.io$ yarn 这里为了保险起见我没把项目放到中文目录下，直接在D盘建的文件夹。 生成并运行Hexo： 12345$ hexo clean# g 即 generate$ hexo g# s 即 serve$ hexo s 打开浏览器localhost:4000，即可看到效果： 注意到地址栏了吗？我已经把它部署到Github Pages上了，要实现这样的效果，请看下回分解~ 哦不，是下一步。 三、部署到Github Pages本地安装git以及如何连接到github的过程就不在这里讲了，下面直接开始正文： 安装hexo-deployer-git： 1$ yarn add hexo-deployer-git 在生成的项目中可以看到有一个_config.yml的文件，它是hexo的用户配置文件： 我们需要在这里配置自己刚刚创建的Github Pages地址，在该文件中搜索deploy或直接到文件末尾，做出类似下图的修改： 然后命令行中输入： 12# d 即 deploy$ hexo d 如果是第一次执行这个命令会让你输入github的账号密码，输入之后就能够发布到Github Pages上了。 四、个性化配置1、主题配置主题可以在https://hexo.io/themes上面找到自己满意的，不过这里我还是推荐朴素又不失内涵的next主题，它还有四个子主题可供选择。 将主题下载下来后(直接download zip就行了，用git命令感觉好慢)，解压并将目录重命名为next，然后放到hexo项目的/themes/下。 然后打开项目（站点）配置文件_config.yml，搜索theme或直接到文件末尾，将默认主题改为next即可。 然后重新运行hexo s就可以看到主题已经改变。 2、设置语言运行后发现整个页面都是英文，我大字都不识几个让我看英文？这可不行。 打开站点配置文件_config.yml及主题配置文件/themes/next/_config.yml，搜索到language，并将其改为zh-CN即可。 放上我更换主题以及换了语言之后的页面样子： 3、设置next子主题咦，你的next主题怎么和我的不一样？我也要我也要~ 在刚刚hexo-next的github页面可以看到这个主题下一共有四个子主题可供选择： 经过一番挑选，我觉得Gemini可能更养眼一点，打开主题配置文件/themes/next/_config.yml，搜索scheme，将其改为Gemini并重新生成页面即可。 4、支持RSS如果自己能读到自己的Feed，那该有多好~ 安装hexo-generator-feed插件： 1$ yarn add hexo-generator-feed 完毕！ 没错，就是这么简单！ 点击RSS链接，就会跳转到atom.xml页面，这就表示RSS已经成功生成了。 五、使用hexo-client说了大半天，花里胡哨，我要怎么不费吹灰之力新建文章编辑文章？ 打开https://github.com/gaoyoubo/hexo-client这个仓库，在README的最下方有最新版的下载地址，然后下载并安装。 首次进入需要设置hexo项目的目录，设置即可。 目前整个项目还很简陋，编辑文章时虽说有上传图片的功能，但却不能通过剪切板上传，还是很鸡肋的。所以现在这篇文章我就是通过Typora来编写，PicGo来上传图片的。 整个软件用起来并不复杂，稍微摸索以下就会了，只是添加标签和分类的功能肉眼是找不到的，需要在编辑文章时找到Front-matter，在这个里面配置标签、分类信息： 其中title为tags表示标签，categories表示分类，如果要添加多个，需要使用yml文件的数组格式。 附录在查找问题的过程中了解到Hexo的文档，以后要深入折腾的话可以参考一下： Hexo文档 Hexo-Next主题配置文档 一般来说，每次更改内容后，最好要依次执行以下下面三个命令： 1234# 这条不执行应该也可以，我这里每次改东西后不执行它也不会有问题$ hexo clean$ hexo g$ hexo s 最后，看hexo官网中的描述，还有好多花样自己没有尝试过，比如评论功能，所以后续应该会有第二篇写hexo的文章。]]></content>
      <categories>
        <category>好多坑</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
